# Auto-generated menu hub_main.py. Do not edit this file on Hub.
# Select run on Hub; no PC-side RUN selection required.
from pybricks.hubs import PrimeHub
from pybricks.parameters import Button, Port
from pybricks.pupdevices import ForceSensor
from pybricks.tools import multitask, run_task, wait

_HUB = None
_TOUCH = None
_LAST_CONTEXT = None
STORAGE_OFFSET = 0
STORAGE_LEN = 1
RUN_MIN = 1

def _make_run01():
    # Auto-generated from run01
    global stop_logging
    # ---- mission: m08_m06_m05 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        #######################################
        # ここにロボットの動作を記述してください

        # M08

        # 最初の目標地点まで前進（450mm）
        print(">>> 実行: await robot.straight(450)")
        await robot.straight(450)

        # 右アームを下げる（速度500、角度-360度）
        print(">>> 実行: await right_lift.run_angle(500,-1100)")
        await right_lift.run_angle(500, -360)

        await wait(100)  # 0.1秒待機

        # 右アームを下げる（速度500、角度-360度）
        print(">>> 実行: await right_lift.run_angle(500,-1100)")
        await right_lift.run_angle(500, -360)

        await wait(100)  # 0.1秒待機

        # 右アームを下げる（速度500、角度-360度）
        print(">>> 実行: await right_lift.run_angle(500,-1100)")
        await right_lift.run_angle(500, -360)

        await wait(50)  # 0.1秒待機    # M06

        # M06

        # 微調整のため左に5度回転
        print(">>> 実行: await robot.turn(-5)")
        await robot.turn(-5)

        # さらに前進（250mm）- 目標位置に近づく
        print(">>> 実行: await robot.straight(250)")
        await robot.straight(250)

        # M05

        await robot.turn(-42)
        await robot.straight(34)

        # 右の車輪だけを少し動かす（180度回転、タイムアウト1.5秒）
        print(">>> 実行: right_wheel.run_angle(200, 140) [タイムアウト1.5秒]")
        await robot.run_motor(right_wheel, 200, 140, timeout=1500)

        # ホームエリアに戻る

        # 時計回りに60度回転
        print(">>> 実行: await robot.turn(45)")
        await robot.turn(50)

        # 後退して初期位置方向に戻る（720mm）- 500mm/sスピード
        print(">>> 実行: await robot.straight(-720) [500mm/sスピード]")
        await robot.straight(-720, speed=500)

        pass  # 何も実行しない場合の構文エラー回避

        ##########################################


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """
        センサー値を定期的にターミナルに表示する非同期タスク。
        他のタスク（ロボットの移動）と並行して実行されます。
        """
        print("--- センサーログタスク開始 ---")
        # 経過時間測定用のタイマーを開始
        logger_timer = StopWatch()
        logger_timer.reset()

        while True:  # プログラムが終了するまで継続的にログを出力
            elapsed_time = logger_timer.time()
            heading = hub.imu.heading()
            left_deg = left_wheel.angle()
            right_deg = right_wheel.angle()
            dist = robot.distance()
            print(
                f"LOG[{elapsed_time:5.0f}ms]: dist={dist:4.0f} mm  heading={heading:4.0f}°  L={left_deg:5.0f}°  R={right_deg:5.0f}°"
            )
            await wait(200)  # 200ミリ秒待機して、他のタスクに実行を譲る


    async def main():
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        run_task(
            multitask(
                sensor_logger_task(hub, robot, left_wheel, right_wheel),
                run(hub, robot, left_wheel, right_wheel, left_lift, right_lift),
            )
        )
    # ---- mission binding ----
    class _MissionModule:
        pass
    m08_m06_m05 = _MissionModule()
    try:
        m08_m06_m05.main = main
    except NameError:
        pass
    try:
        m08_m06_m05.run = run
    except NameError:
        pass
    try:
        m08_m06_m05.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    # ---- mission: m08_m07_m06_m05 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    # グローバル終了フラグ
    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        #######################################
        # ここにロボットの動作を記述してください

        # # M08

        # # 最初の目標地点まで前進（450mm）
        # print(">>> 実行: await robot.straight(450)")
        # await robot.straight(450)

        # # 右アームを下げる（速度500、角度-360度）
        # print(">>> 実行: await right_lift.run_angle(500,-1100)")
        # await right_lift.run_angle(500, -360)

        # await wait(100)  # 0.1秒待機

        # # 右アームを下げる（速度500、角度-360度）
        # print(">>> 実行: await right_lift.run_angle(500,-1100)")
        # await right_lift.run_angle(500, -360)

        # await wait(100)  # 0.1秒待機

        # # 右アームを下げる（速度500、角度-360度）
        # print(">>> 実行: await right_lift.run_angle(500,-1100)")
        # await right_lift.run_angle(500, -360)

        # M07
        # 左アーム下げる
        print(">>> 実行: await left_lift.run_angle(500, -360)")
        await left_lift.run_angle(500, -360)

        # 前進
        print(">>> 実行: await robot.straight(100)")
        await robot.straight(100)

        # 左アームを上げる
        print(">>> 実行: await left_lift.run_angle(500, 360)")
        await left_lift.run_angle(500, -150)



        pass  # 何も実行しない場合の構文エラー回避

        ##########################################


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """
        センサー値を定期的にターミナルに表示する非同期タスク。
        他のタスク（ロボットの移動）と並行して実行されます。
        """
        print("--- センサーログタスク開始 ---")
        # 経過時間測定用のタイマーを開始
        logger_timer = StopWatch()
        logger_timer.reset()

        global stop_logging
        while not stop_logging:  # プログラムが終了するまで継続的にログを出力
            elapsed_time = logger_timer.time()
            heading = hub.imu.heading()
            left_deg = left_wheel.angle()
            right_deg = right_wheel.angle()
            dist = robot.distance()
            print(
                f"LOG[{elapsed_time:5.0f}ms]: dist={dist:4.0f} mm  heading={heading:4.0f}°  L={left_deg:5.0f}°  R={right_deg:5.0f}°"
            )
            await wait(200)  # 200ミリ秒待機して、他のタスクに実行を譲る


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    m08_m07_m06_m05 = _MissionModule()
    try:
        m08_m07_m06_m05.main = main
    except NameError:
        pass
    try:
        m08_m07_m06_m05.run = run
    except NameError:
        pass
    try:
        m08_m07_m06_m05.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        m08_m07_m06_m05.stop_logging = stop_logging
    except NameError:
        pass
    # ---- setup ----
    """
    【ロボット初期化ファイル】
    このファイルは、ロボットを使い始める前に必要な「準備作業」をまとめたものです。
    料理を始める前に、材料を並べたり、調理器具を準備するのと同じように、
    ロボットもプログラムを動かす前に、モーターやセンサーの設定が必要です。

    【このファイルでやること】
    1. ハブ（ロボットの脳みそ）の向きを設定
    2. モーター（タイヤやアームを動かす装置）の設定
    3. ロボットの速度やパワーの設定
    4. PID制御（ロボットをまっすぐ動かすための調整機能）の設定
    5. センサーの初期化

    【使い方】
    他のプログラムから「initialize_robot()」という関数を呼ぶだけで、
    すべての準備が自動的に完了します。
    """

    # ===== ライブラリのインポート =====
    # LEGOロボットを動かすために必要な道具を読み込みます
    from pybricks.hubs import PrimeHub  # ロボットの「脳みそ」（ハブ）を使うための道具
    from pybricks.parameters import Axis, Direction, Port  # ポート、軸、方向などの設定
    from pybricks.pupdevices import Motor  # モーターを使うための道具
    from pybricks.robotics import DriveBase  # ロボットの移動機能を使うための道具
    from pybricks.tools import StopWatch, wait

    # ===== デフォルトの速度・加速度設定 =====
    # 各runファイルから共通で使用できる設定値

    # 直進時の設定
    DEFAULT_STRAIGHT_SETTINGS = {"straight_speed": 400, "straight_acceleration": 500}

    # 回転時の設定
    DEFAULT_TURN_SETTINGS = {"turn_rate": 240, "turn_acceleration": 850}

    # カーブ時の設定
    DEFAULT_CURVE_SETTINGS = {"straight_speed": 240, "straight_acceleration": 800}


    async def run_with_timeout(start_fn, done_fn, stop_fn, timeout_ms, poll_ms=10):
        """
        非同期ループで完了を監視し、タイムアウトで停止する共通関数。
        """
        start_fn()
        timer = StopWatch()
        timer.reset()

        while timer.time() < timeout_ms:
            if done_fn():
                return True
            await wait(poll_ms)

        stop_fn()
        return False


    def apply_curve_settings(set_settings_fn, speed=None, acceleration=None):
        """
        カーブ用の速度・加速度設定を適用するユーティリティ。
        """
        params = {}
        if speed is not None:
            params["straight_speed"] = speed
        if acceleration is not None:
            params["straight_acceleration"] = acceleration
        if params:
            set_settings_fn(**params)


    # ===== ハブの設定をする関数 =====
    def setup_hub():
        """
        ハブ（ロボットの脳みそ）の向きを設定する関数

        【説明】
        ハブには「どちらが上か」「どちらが前か」を教える必要があります。
        これを正しく設定しないと、ロボットが正しく動きません。

        【設定内容】
        - top_side=Axis.Z : Z軸が上向き
        - front_side=Axis.X : X軸が前向き
        """
        return PrimeHub(top_side=Axis.Z, front_side=Axis.X)


    # ===== モーターの設定をする関数 =====
    def setup_motors():
        """
        4つのモーター（左右のタイヤ、左右のリフト）を設定する関数

        【説明】
        ロボットには4つのモーターがあります：
        1. 左のタイヤ用モーター
        2. 右のタイヤ用モーター
        3. 左のリフト（アーム）用モーター
        4. 右のリフト（アーム）用モーター

        それぞれのモーターがどのポート（差し込み口）に接続されているか、
        どちらの方向を「正」とするかを設定します。

        【ポートの接続】
        - Port.F : 左タイヤ（反時計回りが正の方向）
        - Port.B : 右タイヤ（時計回りが正の方向）
        - Port.E : 左リフト（時計回りが正の方向）
        - Port.A : 右リフト（時計回りが正の方向）
        """
        # 左タイヤのモーター（ポートFに接続、反時計回りが正）
        left_wheel = Motor(Port.F, positive_direction=Direction.COUNTERCLOCKWISE)
        # 右タイヤのモーター（ポートBに接続、時計回りが正）
        right_wheel = Motor(Port.B, positive_direction=Direction.CLOCKWISE)
        # 左リフトのモーター（ポートEに接続、時計回りが正）
        left_lift = Motor(Port.E, positive_direction=Direction.CLOCKWISE)
        # 右リフトのモーター（ポートAに接続、時計回りが正）
        right_lift = Motor(Port.A, positive_direction=Direction.CLOCKWISE)

        # 4つのモーターをまとめて返す
        return left_wheel, right_wheel, left_lift, right_lift


    # ===== Robotクラス（DriveBaseのラッパー） =====
    class Robot:
        """
        DriveBaseをラップした便利なロボットクラス

        【このクラスの特徴】
        straight(), turn(), curve() でスピードを直接指定できます。

        【使用例】
        await robot.straight(200, speed=220)       # 220mm/sで200mm前進
        await robot.turn(90, rate=300)              # 300deg/sで90度回転
        await robot.curve(200, 45, speed=150)       # 150mm/sでカーブ

        スピードを指定しない場合は、デフォルト設定が使われます。
        """

        def __init__(self, drivebase):
            """DriveBaseを受け取って初期化"""
            self._robot = drivebase

        async def straight(self, distance, speed=None, acceleration=None, timeout=None):
            """
            直進する（スピード・タイムアウト指定可能）

            【パラメータ】
            - distance: 移動距離（mm）。正の値で前進、負の値で後退
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if speed is not None or acceleration is not None:
                self._robot.settings(
                    straight_speed=(
                        speed if speed is not None else DEFAULT_STRAIGHT_SETTINGS["straight_speed"]
                    ),
                    straight_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_STRAIGHT_SETTINGS["straight_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.straight(distance, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await self._robot.straight(distance)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def turn(self, angle, rate=None, acceleration=None, timeout=None):
            """
            その場で回転する（スピード・タイムアウト指定可能）

            【パラメータ】
            - angle: 回転角度（度）。正の値で右回転、負の値で左回転
            - rate: 回転速度（deg/s）。省略時はデフォルト設定
            - acceleration: 回転加速度（deg/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if rate is not None or acceleration is not None:
                self._robot.settings(
                    turn_rate=rate if rate is not None else DEFAULT_TURN_SETTINGS["turn_rate"],
                    turn_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_TURN_SETTINGS["turn_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.turn(angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.turn(angle)

            # デフォルト設定に戻す
            if rate is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_TURN_SETTINGS)

        async def curve(self, radius, angle, speed=None, acceleration=None, timeout=None):
            """
            カーブする（スピード・タイムアウト指定可能）

            【パラメータ】
            - radius: カーブの半径（mm）
            - angle: 回転角度（度）
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定（指定があれば上書き）
            apply_curve_settings(
                self._robot.settings,
                speed if speed is not None else None,
                acceleration if acceleration is not None else None,
            )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.curve(radius, angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.curve(radius, angle)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def run_motor(self, motor, speed, angle, timeout=None):
            """
            個別のモーターを回転させる（タイムアウト指定可能）

            【パラメータ】
            - motor: 対象のモーター（left_wheel, right_wheel, left_lift, right_liftなど）
            - speed: 回転速度（deg/s）
            - angle: 回転角度（度）
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし

            【使用例】
            await robot.run_motor(right_wheel, 200, 140, timeout=1500)
            await robot.run_motor(left_lift, 300, 180)
            """
            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: motor.run_angle(speed, angle, wait=False),
                    done_fn=lambda: motor.control.done(),
                    stop_fn=motor.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await motor.run_angle(speed, angle)

        # ----- 元のDriveBaseのメソッドをそのまま使えるようにする -----
        def stop(self):
            """ロボットを停止"""
            self._robot.stop()

        def reset(self):
            """走行距離などをリセット"""
            self._robot.reset()

        def distance(self):
            """走行距離を取得"""
            return self._robot.distance()

        def settings(self, **kwargs):
            """設定を変更（元のDriveBase.settingsと同じ）"""
            self._robot.settings(**kwargs)

        def done(self):
            """現在の移動が完了したかどうか"""
            return self._robot.done()

        def use_gyro(self, use):
            """ジャイロセンサーの使用設定"""
            self._robot.use_gyro(use)

        def distance_control(self):
            """距離制御（PID設定用）"""
            return self._robot.distance_control

        def heading_control(self):
            """方向制御（PID設定用）"""
            return self._robot.heading_control


    # ===== ロボットのパラメータ（動作の設定）をする関数 =====
    def setup_robot_parameters(left_wheel, right_wheel):
        """
        ロボットの動く速度を設定する関数

        【説明】
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで定義された
        デフォルト値が自動的に適用されます。

        【返り値】
        Robotクラスのインスタンス（DriveBaseをラップしたもの）
        """

        # ----- ロボットの物理的な大きさを設定 -----
        drivebase = DriveBase(
            left_wheel,  # 左タイヤのモーター
            right_wheel,  # 右タイヤのモーター
            wheel_diameter=62,  # タイヤの直径（mm）
            axle_track=115,  # 左右のタイヤの間隔（mm）
        )

        # ----- デフォルトの速度・加速度を自動適用 -----
        drivebase.settings(**DEFAULT_STRAIGHT_SETTINGS, **DEFAULT_TURN_SETTINGS)
        print(f"✓ デフォルト設定適用: 直進={DEFAULT_STRAIGHT_SETTINGS}, 回転={DEFAULT_TURN_SETTINGS}")

        # Robotクラスでラップして返す
        return Robot(drivebase)


    # ===== PID制御の設定をする関数 =====
    def setup_pid_control(robot):
        """
        PID制御を設定する関数

        【PID制御とは？】
        ロボットをまっすぐ正確に動かすための「自動調整機能」です。

        例えば、車を運転するときに、カーブでハンドルを少しずつ調整しますよね？
        PID制御は、ロボットが自動的にこの調整をしてくれる機能です。

        【PIDの意味】
        - P (Proportional: 比例) : 目標からどれくらいズレているかに応じて調整
        - I (Integral: 積分) : 過去のズレを積み重ねて調整
        - D (Derivative: 微分) : ズレの変化の速さに応じて調整

        【2種類のPID制御】
        1. 距離制御 (DISTANCE) : 「どれくらい進むか」を正確にコントロール
        2. 方向制御 (HEADING) : 「どの方向を向くか」を正確にコントロール

        【注意】
        下の数値（KP, KI, KD）は「ゲイン」と呼ばれ、調整の強さを決めます。
        この数値を変えると、ロボットの動きが変わります。
        うまく動かない場合は、これらの数値を調整する必要があります。
        """

        # ----- 距離制御用のPIDゲイン（「進む距離」をコントロール） -----
        DISTANCE_KP = 1000  # P（比例）ゲイン: 目標との距離差に対する反応の強さ
        DISTANCE_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        DISTANCE_KD = 10  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- 方向制御用のPIDゲイン（「向き」をコントロール） -----
        HEADING_KP = 2000  # P（比例）ゲイン: 目標との角度差に対する反応の強さ
        HEADING_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        HEADING_KD = 100  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- ロボットにPIDゲインを設定 -----
        # 距離制御のPIDゲインを設定
        robot.distance_control().pid(kp=DISTANCE_KP, ki=DISTANCE_KI, kd=DISTANCE_KD)

        # 方向制御のPIDゲインを設定
        robot.heading_control().pid(kp=HEADING_KP, ki=HEADING_KI, kd=HEADING_KD)


    # ===== センサーを初期化する関数 =====
    def initialize_sensors(hub, robot):
        """
        センサーとジャイロ（方向センサー）を初期化する関数

        【説明】
        ロボットには「ジャイロセンサー」という、スマートフォンの画面回転機能と同じような
        センサーが付いています。これは「ロボットがどちらを向いているか」を測定します。

        【やること】
        1. ジャイロセンサーを使用する設定にする
        2. 方向を0度（まっすぐ）にリセット
        3. ロボットの走行距離などをリセット

        【なぜ必要？】
        プログラムを実行する前に、「今がスタート地点」だと教える必要があります。
        これをしないと、前のプログラムの影響が残ってしまいます。
        """
        robot.use_gyro(True)  # ジャイロセンサーを使う設定にする
        hub.imu.reset_heading(0)  # 方向を0度（正面）にリセット
        robot.reset()  # ロボットの走行距離や回転角度をリセット


    # ===== モーターの角度をリセットする関数 =====
    def reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift):
        """
        すべてのモーターの角度を0度にリセットする関数

        【説明】
        モーターは回転した角度を記録しています。
        例えば、タイヤが360度回転したら「1回転した」と記録されます。

        この関数は、すべてのモーターの角度を0度に戻します。
        時計の針を12時の位置に戻すようなイメージです。

        【対象モーター】
        - 左タイヤ
        - 右タイヤ
        - 左リフト（アーム）
        - 右リフト（アーム）

        【なぜ必要？】
        プログラムを実行する前に、モーターの角度をリセットしないと、
        「前回どこまで回転したか」の情報が残ってしまい、正確に動きません。
        """
        left_wheel.reset_angle(0)  # 左タイヤのモーターを0度にリセット
        right_wheel.reset_angle(0)  # 右タイヤのモーターを0度にリセット
        left_lift.reset_angle(0)  # 左リフトのモーターを0度にリセット
        right_lift.reset_angle(0)  # 右リフトのモーターを0度にリセット
        print("✓ モーター角度リセット完了: 全モーター=0°")


    # ===== ロボット全体を初期化する関数（メイン関数） =====
    def initialize_robot():
        """
        ロボットを使う準備を全部まとめて行う関数

        【説明】
        この関数は、上で定義した5つの関数をすべて実行して、
        ロボットを使えるようにします。
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで
        定義されたデフォルト値が自動的に適用されます。

        【実行する処理（順番通り）】
        1. ハブの設定
        2. モーターの設定
        3. ロボットパラメータの設定
        4. PID制御の設定
        5. センサーの初期化
        6. モーター角度のリセット

        【返り値（戻ってくる値）】
        この関数は、以下の6つの情報を返します：
        - hub : ハブ（ロボットの脳みそ）
        - robot : ロボット全体のオブジェクト
        - left_wheel : 左タイヤのモーター
        - right_wheel : 右タイヤのモーター
        - left_lift : 左リフトのモーター
        - right_lift : 右リフトのモーター

        【使い方の例】
        他のプログラムから以下のように使います：
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        """
        print("=== ロボット初期化開始 ===")

        # ----- ステップ1: ハブの設定 -----
        hub = setup_hub()
        print("✓ ハブ設定完了")

        # ----- ステップ2: モーターの設定 -----
        left_wheel, right_wheel, left_lift, right_lift = setup_motors()
        print("✓ モーター設定完了")

        # ----- ステップ3: ロボットパラメータの設定 -----
        robot = setup_robot_parameters(left_wheel, right_wheel)
        print("✓ ロボットパラメータ設定完了")

        # ----- ステップ4: PID制御の設定 -----
        setup_pid_control(robot)
        print("✓ PID制御設定完了")

        # ----- ステップ5: センサーの初期化 -----
        initialize_sensors(hub, robot)
        print("✓ センサー初期化完了")

        # ----- ステップ6: モーター角度のリセット -----
        reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift)

        print("=== ロボット初期化完了 ===")

        # ----- すべての設定情報を返す -----
        return hub, robot, left_wheel, right_wheel, left_lift, right_lift
    # ---- main ----
    from pybricks.tools import StopWatch, multitask, run_task, wait
    _variant_m08_m06_m05 = m08_m06_m05
    _variant_m08_m07_m06_m05 = m08_m07_m06_m05

    CURRENT_MISSION = None
    ACTIVE_VARIANT = "m08_m06_m05"
    VARIANTS = {
        "m08_m06_m05": _variant_m08_m06_m05,
        "m08_m07_m06_m05": _variant_m08_m07_m06_m05,
    }


    async def run_with_timing(label, coro_fn):
        timer = StopWatch()
        timer.reset()
        print(f"[RUN] {label} start")
        result = await coro_fn()
        elapsed_ms = timer.time()
        print(f"[RUN] {label} done ({elapsed_ms:.0f} ms)")
        return result


    def get_active_variant_name():
        if isinstance(CURRENT_MISSION, str) and CURRENT_MISSION in VARIANTS:
            return CURRENT_MISSION
        for name, variant in VARIANTS.items():
            if getattr(variant, "IS_CURRENT", False):
                return name
        return ACTIVE_VARIANT


    def load_variant():
        """ACTIVE_VARIANT/CURRENT_MISSION/IS_CURRENT からモジュールを返す。"""
        name = get_active_variant_name()
        return name, VARIANTS[name]


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        variant_name, variant = load_variant()
        label = f"run01:{variant_name}"
        return await run_with_timing(
            label,
            lambda: variant.run(
                hub,
                robot,
                left_wheel,
                right_wheel,
                left_lift,
                right_lift,
            ),
        )


    def main(hub=None, robot=None, left_wheel=None, right_wheel=None, left_lift=None, right_lift=None):
        if hub is None:
            hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        variant_name, variant = load_variant()
        label = f"run01:{variant_name}"

        async def timed_run():
            await run_with_timing(
                label,
                lambda: variant.run(
                    hub,
                    robot,
                    left_wheel,
                    right_wheel,
                    left_lift,
                    right_lift,
                ),
            )

        if hasattr(variant, "sensor_logger_task"):
            if "stop_logging" in globals():

                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)

                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        wrapped_run(),
                    )
                )
            else:
                run_task(multitask(variant.sensor_logger_task(hub, robot, left_wheel, right_wheel), timed_run()))
        else:
            run_task(timed_run())
    # ---- run entry ----
    async def _run_entry(ctx):
        variant = load_variant()
        has_stop_logging = "stop_logging" in globals()
        async def timed_run():
            await run(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel, ctx.left_lift, ctx.right_lift)
        if hasattr(variant, "sensor_logger_task"):
            if has_stop_logging:
                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), wrapped_run())
            else:
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), timed_run())
        else:
            await timed_run()
    return RunBundle(initialize_robot, _run_entry)

def _make_run02():
    # Auto-generated from run02
    global stop_logging
    # ---- mission: m09_m07 ----
    from pybricks.tools import multitask, run_task, wait

    # グローバル終了フラグ
    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        """
        ラン2: M09, M07
        """
        # ラン2だけ、他のランとは異なり低速で動くようにする
        # 直進速度: 800mm/s * 40% = 320mm/s
        # 回転速度: 200deg/s * 30% = 60deg/s
        robot.settings(straight_speed=320, turn_rate=60)

        # ここにロボットの動作を記述してください

        # M09
        await robot.curve(120, 110)  # 半径120mmで90度カーブ M09に向けて方向転換
        await robot.curve(120, -64)  # 半径120mmで-90度カーブ M09に向けて方向転換

        robot.settings(straight_speed=220)  # M09に向けて前進
        await robot.straight(200)

        await robot.straight(-192)  # M09の台を引っ張って後進

        await wait(200)  # 0.2秒待機

        await robot.curve(710, 10)  # M09に向けて前進

        await wait(150)  # 0.15秒待機

        # 右のタイヤだけを回して回転
        await right_wheel.run_angle(100, 170)  # 速度100で回転 M09の下の台を回転して上げる

        await wait(100)  # 0.1秒待機

        # M07
        await robot.straight(-210)  # 後進でM09から離れる
        await robot.turn(45)  # M07へ向けて方向転換
        await robot.straight(210)  # M07に向けて前進
        await robot.turn(65)  # M07に向けて方向転換
        await robot.straight(90)  # M07に向けて前進

        await right_lift.run_angle(1000, -850)  # 速度1000でリフト操作（台を上げる）
        await robot.straight(100)
        await right_lift.run_angle(800, 720)  # 右のアームを上げる

        # 左側にいくバージョン
        robot.settings(straight_speed=400)
        await robot.straight(-550)
        await robot.turn(58)
        robot.settings(straight_speed=600)  # スピードを600mm/sに上げる
        await robot.straight(-800)
        await robot.turn(-22)
        await robot.straight(-650)

        robot.stop()
        print("# 走行完了！")


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的に表示するタスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        while not stop_logging:
            heading = hub.imu.heading()
            left_deg = left_wheel.angle()
            right_deg = right_wheel.angle()
            dist = robot.distance()
            print(
                f"LOG: dist={dist:4.0f} mm  heading={heading:4.0f}°  L={left_deg:5.0f}°  R={right_deg:5.0f}°"
            )
            await wait(200)
        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    m09_m07 = _MissionModule()
    try:
        m09_m07.main = main
    except NameError:
        pass
    try:
        m09_m07.run = run
    except NameError:
        pass
    try:
        m09_m07.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        m09_m07.stop_logging = stop_logging
    except NameError:
        pass
    # ---- setup ----
    """
    【ロボット初期化ファイル】
    このファイルは、ロボットを使い始める前に必要な「準備作業」をまとめたものです。
    料理を始める前に、材料を並べたり、調理器具を準備するのと同じように、
    ロボットもプログラムを動かす前に、モーターやセンサーの設定が必要です。

    【このファイルでやること】
    1. ハブ（ロボットの脳みそ）の向きを設定
    2. モーター（タイヤやアームを動かす装置）の設定
    3. ロボットの速度やパワーの設定
    4. PID制御（ロボットをまっすぐ動かすための調整機能）の設定
    5. センサーの初期化

    【使い方】
    他のプログラムから「initialize_robot()」という関数を呼ぶだけで、
    すべての準備が自動的に完了します。
    """

    # ===== ライブラリのインポート =====
    # LEGOロボットを動かすために必要な道具を読み込みます
    from pybricks.hubs import PrimeHub  # ロボットの「脳みそ」（ハブ）を使うための道具
    from pybricks.parameters import Axis, Direction, Port  # ポート、軸、方向などの設定
    from pybricks.pupdevices import Motor  # モーターを使うための道具
    from pybricks.robotics import DriveBase  # ロボットの移動機能を使うための道具
    from pybricks.tools import StopWatch, wait

    # ===== デフォルトの速度・加速度設定 =====
    # 各runファイルから共通で使用できる設定値

    # 直進時の設定
    DEFAULT_STRAIGHT_SETTINGS = {"straight_speed": 400, "straight_acceleration": 500}

    # 回転時の設定
    DEFAULT_TURN_SETTINGS = {"turn_rate": 240, "turn_acceleration": 850}

    # カーブ時の設定
    DEFAULT_CURVE_SETTINGS = {"straight_speed": 240, "straight_acceleration": 800}


    async def run_with_timeout(start_fn, done_fn, stop_fn, timeout_ms, poll_ms=10):
        """
        非同期ループで完了を監視し、タイムアウトで停止する共通関数。
        """
        start_fn()
        timer = StopWatch()
        timer.reset()

        while timer.time() < timeout_ms:
            if done_fn():
                return True
            await wait(poll_ms)

        stop_fn()
        return False


    def apply_curve_settings(set_settings_fn, speed=None, acceleration=None):
        """
        カーブ用の速度・加速度設定を適用するユーティリティ。
        """
        params = {}
        if speed is not None:
            params["straight_speed"] = speed
        if acceleration is not None:
            params["straight_acceleration"] = acceleration
        if params:
            set_settings_fn(**params)


    # ===== ハブの設定をする関数 =====
    def setup_hub():
        """
        ハブ（ロボットの脳みそ）の向きを設定する関数

        【説明】
        ハブには「どちらが上か」「どちらが前か」を教える必要があります。
        これを正しく設定しないと、ロボットが正しく動きません。

        【設定内容】
        - top_side=Axis.Z : Z軸が上向き
        - front_side=Axis.X : X軸が前向き
        """
        return PrimeHub(top_side=Axis.Z, front_side=Axis.X)


    # ===== モーターの設定をする関数 =====
    def setup_motors():
        """
        4つのモーター（左右のタイヤ、左右のリフト）を設定する関数

        【説明】
        ロボットには4つのモーターがあります：
        1. 左のタイヤ用モーター
        2. 右のタイヤ用モーター
        3. 左のリフト（アーム）用モーター
        4. 右のリフト（アーム）用モーター

        それぞれのモーターがどのポート（差し込み口）に接続されているか、
        どちらの方向を「正」とするかを設定します。

        【ポートの接続】
        - Port.F : 左タイヤ（反時計回りが正の方向）
        - Port.B : 右タイヤ（時計回りが正の方向）
        - Port.E : 左リフト（時計回りが正の方向）
        - Port.A : 右リフト（時計回りが正の方向）
        """
        # 左タイヤのモーター（ポートFに接続、反時計回りが正）
        left_wheel = Motor(Port.F, positive_direction=Direction.COUNTERCLOCKWISE)
        # 右タイヤのモーター（ポートBに接続、時計回りが正）
        right_wheel = Motor(Port.B, positive_direction=Direction.CLOCKWISE)
        # 左リフトのモーター（ポートEに接続、時計回りが正）
        left_lift = Motor(Port.E, positive_direction=Direction.CLOCKWISE)
        # 右リフトのモーター（ポートAに接続、時計回りが正）
        right_lift = Motor(Port.A, positive_direction=Direction.CLOCKWISE)

        # 4つのモーターをまとめて返す
        return left_wheel, right_wheel, left_lift, right_lift


    # ===== Robotクラス（DriveBaseのラッパー） =====
    class Robot:
        """
        DriveBaseをラップした便利なロボットクラス

        【このクラスの特徴】
        straight(), turn(), curve() でスピードを直接指定できます。

        【使用例】
        await robot.straight(200, speed=220)       # 220mm/sで200mm前進
        await robot.turn(90, rate=300)              # 300deg/sで90度回転
        await robot.curve(200, 45, speed=150)       # 150mm/sでカーブ

        スピードを指定しない場合は、デフォルト設定が使われます。
        """

        def __init__(self, drivebase):
            """DriveBaseを受け取って初期化"""
            self._robot = drivebase

        async def straight(self, distance, speed=None, acceleration=None, timeout=None):
            """
            直進する（スピード・タイムアウト指定可能）

            【パラメータ】
            - distance: 移動距離（mm）。正の値で前進、負の値で後退
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if speed is not None or acceleration is not None:
                self._robot.settings(
                    straight_speed=(
                        speed if speed is not None else DEFAULT_STRAIGHT_SETTINGS["straight_speed"]
                    ),
                    straight_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_STRAIGHT_SETTINGS["straight_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.straight(distance, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await self._robot.straight(distance)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def turn(self, angle, rate=None, acceleration=None, timeout=None):
            """
            その場で回転する（スピード・タイムアウト指定可能）

            【パラメータ】
            - angle: 回転角度（度）。正の値で右回転、負の値で左回転
            - rate: 回転速度（deg/s）。省略時はデフォルト設定
            - acceleration: 回転加速度（deg/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if rate is not None or acceleration is not None:
                self._robot.settings(
                    turn_rate=rate if rate is not None else DEFAULT_TURN_SETTINGS["turn_rate"],
                    turn_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_TURN_SETTINGS["turn_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.turn(angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.turn(angle)

            # デフォルト設定に戻す
            if rate is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_TURN_SETTINGS)

        async def curve(self, radius, angle, speed=None, acceleration=None, timeout=None):
            """
            カーブする（スピード・タイムアウト指定可能）

            【パラメータ】
            - radius: カーブの半径（mm）
            - angle: 回転角度（度）
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定（指定があれば上書き）
            apply_curve_settings(
                self._robot.settings,
                speed if speed is not None else None,
                acceleration if acceleration is not None else None,
            )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.curve(radius, angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.curve(radius, angle)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def run_motor(self, motor, speed, angle, timeout=None):
            """
            個別のモーターを回転させる（タイムアウト指定可能）

            【パラメータ】
            - motor: 対象のモーター（left_wheel, right_wheel, left_lift, right_liftなど）
            - speed: 回転速度（deg/s）
            - angle: 回転角度（度）
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし

            【使用例】
            await robot.run_motor(right_wheel, 200, 140, timeout=1500)
            await robot.run_motor(left_lift, 300, 180)
            """
            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: motor.run_angle(speed, angle, wait=False),
                    done_fn=lambda: motor.control.done(),
                    stop_fn=motor.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await motor.run_angle(speed, angle)

        # ----- 元のDriveBaseのメソッドをそのまま使えるようにする -----
        def stop(self):
            """ロボットを停止"""
            self._robot.stop()

        def reset(self):
            """走行距離などをリセット"""
            self._robot.reset()

        def distance(self):
            """走行距離を取得"""
            return self._robot.distance()

        def settings(self, **kwargs):
            """設定を変更（元のDriveBase.settingsと同じ）"""
            self._robot.settings(**kwargs)

        def done(self):
            """現在の移動が完了したかどうか"""
            return self._robot.done()

        def use_gyro(self, use):
            """ジャイロセンサーの使用設定"""
            self._robot.use_gyro(use)

        def distance_control(self):
            """距離制御（PID設定用）"""
            return self._robot.distance_control

        def heading_control(self):
            """方向制御（PID設定用）"""
            return self._robot.heading_control


    # ===== ロボットのパラメータ（動作の設定）をする関数 =====
    def setup_robot_parameters(left_wheel, right_wheel):
        """
        ロボットの動く速度を設定する関数

        【説明】
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで定義された
        デフォルト値が自動的に適用されます。

        【返り値】
        Robotクラスのインスタンス（DriveBaseをラップしたもの）
        """

        # ----- ロボットの物理的な大きさを設定 -----
        drivebase = DriveBase(
            left_wheel,  # 左タイヤのモーター
            right_wheel,  # 右タイヤのモーター
            wheel_diameter=62,  # タイヤの直径（mm）
            axle_track=115,  # 左右のタイヤの間隔（mm）
        )

        # ----- デフォルトの速度・加速度を自動適用 -----
        drivebase.settings(**DEFAULT_STRAIGHT_SETTINGS, **DEFAULT_TURN_SETTINGS)
        print(f"✓ デフォルト設定適用: 直進={DEFAULT_STRAIGHT_SETTINGS}, 回転={DEFAULT_TURN_SETTINGS}")

        # Robotクラスでラップして返す
        return Robot(drivebase)


    # ===== PID制御の設定をする関数 =====
    def setup_pid_control(robot):
        """
        PID制御を設定する関数

        【PID制御とは？】
        ロボットをまっすぐ正確に動かすための「自動調整機能」です。

        例えば、車を運転するときに、カーブでハンドルを少しずつ調整しますよね？
        PID制御は、ロボットが自動的にこの調整をしてくれる機能です。

        【PIDの意味】
        - P (Proportional: 比例) : 目標からどれくらいズレているかに応じて調整
        - I (Integral: 積分) : 過去のズレを積み重ねて調整
        - D (Derivative: 微分) : ズレの変化の速さに応じて調整

        【2種類のPID制御】
        1. 距離制御 (DISTANCE) : 「どれくらい進むか」を正確にコントロール
        2. 方向制御 (HEADING) : 「どの方向を向くか」を正確にコントロール

        【注意】
        下の数値（KP, KI, KD）は「ゲイン」と呼ばれ、調整の強さを決めます。
        この数値を変えると、ロボットの動きが変わります。
        うまく動かない場合は、これらの数値を調整する必要があります。
        """

        # ----- 距離制御用のPIDゲイン（「進む距離」をコントロール） -----
        DISTANCE_KP = 1000  # P（比例）ゲイン: 目標との距離差に対する反応の強さ
        DISTANCE_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        DISTANCE_KD = 10  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- 方向制御用のPIDゲイン（「向き」をコントロール） -----
        HEADING_KP = 2000  # P（比例）ゲイン: 目標との角度差に対する反応の強さ
        HEADING_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        HEADING_KD = 100  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- ロボットにPIDゲインを設定 -----
        # 距離制御のPIDゲインを設定
        robot.distance_control().pid(kp=DISTANCE_KP, ki=DISTANCE_KI, kd=DISTANCE_KD)

        # 方向制御のPIDゲインを設定
        robot.heading_control().pid(kp=HEADING_KP, ki=HEADING_KI, kd=HEADING_KD)


    # ===== センサーを初期化する関数 =====
    def initialize_sensors(hub, robot):
        """
        センサーとジャイロ（方向センサー）を初期化する関数

        【説明】
        ロボットには「ジャイロセンサー」という、スマートフォンの画面回転機能と同じような
        センサーが付いています。これは「ロボットがどちらを向いているか」を測定します。

        【やること】
        1. ジャイロセンサーを使用する設定にする
        2. 方向を0度（まっすぐ）にリセット
        3. ロボットの走行距離などをリセット

        【なぜ必要？】
        プログラムを実行する前に、「今がスタート地点」だと教える必要があります。
        これをしないと、前のプログラムの影響が残ってしまいます。
        """
        robot.use_gyro(True)  # ジャイロセンサーを使う設定にする
        hub.imu.reset_heading(0)  # 方向を0度（正面）にリセット
        robot.reset()  # ロボットの走行距離や回転角度をリセット


    # ===== モーターの角度をリセットする関数 =====
    def reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift):
        """
        すべてのモーターの角度を0度にリセットする関数

        【説明】
        モーターは回転した角度を記録しています。
        例えば、タイヤが360度回転したら「1回転した」と記録されます。

        この関数は、すべてのモーターの角度を0度に戻します。
        時計の針を12時の位置に戻すようなイメージです。

        【対象モーター】
        - 左タイヤ
        - 右タイヤ
        - 左リフト（アーム）
        - 右リフト（アーム）

        【なぜ必要？】
        プログラムを実行する前に、モーターの角度をリセットしないと、
        「前回どこまで回転したか」の情報が残ってしまい、正確に動きません。
        """
        left_wheel.reset_angle(0)  # 左タイヤのモーターを0度にリセット
        right_wheel.reset_angle(0)  # 右タイヤのモーターを0度にリセット
        left_lift.reset_angle(0)  # 左リフトのモーターを0度にリセット
        right_lift.reset_angle(0)  # 右リフトのモーターを0度にリセット
        print("✓ モーター角度リセット完了: 全モーター=0°")


    # ===== ロボット全体を初期化する関数（メイン関数） =====
    def initialize_robot():
        """
        ロボットを使う準備を全部まとめて行う関数

        【説明】
        この関数は、上で定義した5つの関数をすべて実行して、
        ロボットを使えるようにします。
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで
        定義されたデフォルト値が自動的に適用されます。

        【実行する処理（順番通り）】
        1. ハブの設定
        2. モーターの設定
        3. ロボットパラメータの設定
        4. PID制御の設定
        5. センサーの初期化
        6. モーター角度のリセット

        【返り値（戻ってくる値）】
        この関数は、以下の6つの情報を返します：
        - hub : ハブ（ロボットの脳みそ）
        - robot : ロボット全体のオブジェクト
        - left_wheel : 左タイヤのモーター
        - right_wheel : 右タイヤのモーター
        - left_lift : 左リフトのモーター
        - right_lift : 右リフトのモーター

        【使い方の例】
        他のプログラムから以下のように使います：
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        """
        print("=== ロボット初期化開始 ===")

        # ----- ステップ1: ハブの設定 -----
        hub = setup_hub()
        print("✓ ハブ設定完了")

        # ----- ステップ2: モーターの設定 -----
        left_wheel, right_wheel, left_lift, right_lift = setup_motors()
        print("✓ モーター設定完了")

        # ----- ステップ3: ロボットパラメータの設定 -----
        robot = setup_robot_parameters(left_wheel, right_wheel)
        print("✓ ロボットパラメータ設定完了")

        # ----- ステップ4: PID制御の設定 -----
        setup_pid_control(robot)
        print("✓ PID制御設定完了")

        # ----- ステップ5: センサーの初期化 -----
        initialize_sensors(hub, robot)
        print("✓ センサー初期化完了")

        # ----- ステップ6: モーター角度のリセット -----
        reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift)

        print("=== ロボット初期化完了 ===")

        # ----- すべての設定情報を返す -----
        return hub, robot, left_wheel, right_wheel, left_lift, right_lift
    # ---- main ----
    from pybricks.tools import StopWatch, multitask, run_task, wait
    _variant_m09_m07 = m09_m07

    CURRENT_MISSION = None
    ACTIVE_VARIANT = "m09_m07"
    VARIANTS = {"m09_m07": _variant_m09_m07}


    async def run_with_timing(label, coro_fn):
        timer = StopWatch()
        timer.reset()
        print(f"[RUN] {label} start")
        result = await coro_fn()
        elapsed_ms = timer.time()
        print(f"[RUN] {label} done ({elapsed_ms:.0f} ms)")
        return result


    def get_active_variant_name():
        if isinstance(CURRENT_MISSION, str) and CURRENT_MISSION in VARIANTS:
            return CURRENT_MISSION
        for name, variant in VARIANTS.items():
            if getattr(variant, "IS_CURRENT", False):
                return name
        return ACTIVE_VARIANT


    def load_variant():
        name = get_active_variant_name()
        return name, VARIANTS[name]


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        variant_name, variant = load_variant()
        label = f"run02:{variant_name}"
        return await run_with_timing(
            label,
            lambda: variant.run(
                hub,
                robot,
                left_wheel,
                right_wheel,
                left_lift,
                right_lift,
            ),
        )


    def main(hub=None, robot=None, left_wheel=None, right_wheel=None, left_lift=None, right_lift=None):
        if hub is None:
            hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        variant_name, variant = load_variant()
        label = f"run02:{variant_name}"

        async def timed_run():
            await run_with_timing(
                label,
                lambda: variant.run(
                    hub,
                    robot,
                    left_wheel,
                    right_wheel,
                    left_lift,
                    right_lift,
                ),
            )

        if hasattr(variant, "sensor_logger_task"):
            if "stop_logging" in globals():

                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)

                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        wrapped_run(),
                    )
                )
            else:
                run_task(multitask(variant.sensor_logger_task(hub, robot, left_wheel, right_wheel), timed_run()))
        else:
            run_task(timed_run())
    # ---- run entry ----
    async def _run_entry(ctx):
        variant = load_variant()
        has_stop_logging = "stop_logging" in globals()
        async def timed_run():
            await run(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel, ctx.left_lift, ctx.right_lift)
        if hasattr(variant, "sensor_logger_task"):
            if has_stop_logging:
                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), wrapped_run())
            else:
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), timed_run())
        else:
            await timed_run()
    return RunBundle(initialize_robot, _run_entry)

def _make_run03():
    # Auto-generated from run03
    global stop_logging
    # ---- mission: m10_m11 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    # グローバル終了フラグ
    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        #######################################
        # ここにロボットの動作を記述してください

        # 速度・加速度設定を定義
        # 直進時の設定
        straight_settings = {
            "straight_speed": 400,
            "straight_acceleration": 500,
        }

        # 回転時の設定
        turn_settings = {
            "turn_rate": 240,
            "turn_acceleration": 850,
        }

        # M11
        robot.settings(**turn_settings)
        await robot.turn(-45)

        robot.settings(**straight_settings)
        await robot.straight(300)

        robot.settings(**turn_settings)
        await robot.turn(45)

        robot.settings(**straight_settings)
        await robot.straight(500)

        robot.settings(**turn_settings)
        await robot.turn(26)

        robot.settings(**straight_settings)
        await robot.straight(330)

        await right_lift.run_angle(1000, 180 * 40)

        robot.settings(**straight_settings)
        await robot.straight(-130)

        robot.settings(**turn_settings)
        await robot.turn(-26)

        robot.settings(**straight_settings)
        await robot.straight(225)

        # M10
        robot.settings(**turn_settings)
        await robot.turn(-88)

        robot.settings(straight_speed=100, straight_acceleration=200)
        await robot.straight(148, timeout=2000)

        robot.settings(straight_speed=100, straight_acceleration=200)
        await robot.straight(-148)

        robot.settings(turn_rate=100, turn_acceleration=300)
        await robot.turn(106)

        robot.settings(**straight_settings)
        await robot.straight(-430)
        await robot.turn(-28)
        await robot.straight(-900)

        robot.stop()
        print("# 走行完了！")


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的にターミナルに表示する非同期タスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        logger_timer = StopWatch()
        logger_timer.reset()

        print(
            "time,current_dist_mm,error_angle_deg,current_heading_deg,left_angle_deg,right_angle_deg,"
            "angle_diff_deg,left_speed_dps,right_speed_dps,speed_diff_dps,kp_dist,ki_dist,kd_dist,"
            "kp_head,ki_head,kd_head"
        )

        while not stop_logging:
            elapsed_time = logger_timer.time()
            current_dist_mm = robot.distance()
            current_heading_deg = hub.imu.heading()
            left_angle_deg = left_wheel.angle()
            right_angle_deg = right_wheel.angle()
            angle_diff_deg = right_angle_deg - left_angle_deg
            left_speed_dps = left_wheel.speed()
            right_speed_dps = right_wheel.speed()
            speed_diff_dps = right_speed_dps - left_speed_dps

            kp_dist = 1000
            ki_dist = 50
            kd_dist = 10
            kp_head = 2000
            ki_head = 50
            kd_head = 100

            error_angle_deg = 0

            print(
                f"{elapsed_time:.0f},{current_dist_mm:.1f},{error_angle_deg:.1f},{current_heading_deg:.1f},{left_angle_deg:.1f},{right_angle_deg:.1f},{angle_diff_deg:.1f},{left_speed_dps:.1f},{right_speed_dps:.1f},{speed_diff_dps:.1f},{kp_dist:.1f},{ki_dist:.1f},{kd_dist:.1f},{kp_head:.1f},{ki_head:.1f},{kd_head:.1f}"
            )

            await wait(200)

        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    m10_m11 = _MissionModule()
    try:
        m10_m11.main = main
    except NameError:
        pass
    try:
        m10_m11.run = run
    except NameError:
        pass
    try:
        m10_m11.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        m10_m11.stop_logging = stop_logging
    except NameError:
        pass
    # ---- setup ----
    """
    【ロボット初期化ファイル】
    このファイルは、ロボットを使い始める前に必要な「準備作業」をまとめたものです。
    料理を始める前に、材料を並べたり、調理器具を準備するのと同じように、
    ロボットもプログラムを動かす前に、モーターやセンサーの設定が必要です。

    【このファイルでやること】
    1. ハブ（ロボットの脳みそ）の向きを設定
    2. モーター（タイヤやアームを動かす装置）の設定
    3. ロボットの速度やパワーの設定
    4. PID制御（ロボットをまっすぐ動かすための調整機能）の設定
    5. センサーの初期化

    【使い方】
    他のプログラムから「initialize_robot()」という関数を呼ぶだけで、
    すべての準備が自動的に完了します。
    """

    # ===== ライブラリのインポート =====
    # LEGOロボットを動かすために必要な道具を読み込みます
    from pybricks.hubs import PrimeHub  # ロボットの「脳みそ」（ハブ）を使うための道具
    from pybricks.parameters import Axis, Direction, Port  # ポート、軸、方向などの設定
    from pybricks.pupdevices import Motor  # モーターを使うための道具
    from pybricks.robotics import DriveBase  # ロボットの移動機能を使うための道具
    from pybricks.tools import StopWatch, wait

    # ===== デフォルトの速度・加速度設定 =====
    # 各runファイルから共通で使用できる設定値

    # 直進時の設定
    DEFAULT_STRAIGHT_SETTINGS = {"straight_speed": 400, "straight_acceleration": 500}

    # 回転時の設定
    DEFAULT_TURN_SETTINGS = {"turn_rate": 240, "turn_acceleration": 850}

    # カーブ時の設定
    DEFAULT_CURVE_SETTINGS = {"straight_speed": 240, "straight_acceleration": 800}


    async def run_with_timeout(start_fn, done_fn, stop_fn, timeout_ms, poll_ms=10):
        """
        非同期ループで完了を監視し、タイムアウトで停止する共通関数。
        """
        start_fn()
        timer = StopWatch()
        timer.reset()

        while timer.time() < timeout_ms:
            if done_fn():
                return True
            await wait(poll_ms)

        stop_fn()
        return False


    def apply_curve_settings(set_settings_fn, speed=None, acceleration=None):
        """
        カーブ用の速度・加速度設定を適用するユーティリティ。
        """
        params = {}
        if speed is not None:
            params["straight_speed"] = speed
        if acceleration is not None:
            params["straight_acceleration"] = acceleration
        if params:
            set_settings_fn(**params)


    # ===== ハブの設定をする関数 =====
    def setup_hub():
        """
        ハブ（ロボットの脳みそ）の向きを設定する関数

        【説明】
        ハブには「どちらが上か」「どちらが前か」を教える必要があります。
        これを正しく設定しないと、ロボットが正しく動きません。

        【設定内容】
        - top_side=Axis.Z : Z軸が上向き
        - front_side=Axis.X : X軸が前向き
        """
        return PrimeHub(top_side=Axis.Z, front_side=Axis.X)


    # ===== モーターの設定をする関数 =====
    def setup_motors():
        """
        4つのモーター（左右のタイヤ、左右のリフト）を設定する関数

        【説明】
        ロボットには4つのモーターがあります：
        1. 左のタイヤ用モーター
        2. 右のタイヤ用モーター
        3. 左のリフト（アーム）用モーター
        4. 右のリフト（アーム）用モーター

        それぞれのモーターがどのポート（差し込み口）に接続されているか、
        どちらの方向を「正」とするかを設定します。

        【ポートの接続】
        - Port.F : 左タイヤ（反時計回りが正の方向）
        - Port.B : 右タイヤ（時計回りが正の方向）
        - Port.E : 左リフト（時計回りが正の方向）
        - Port.A : 右リフト（時計回りが正の方向）
        """
        # 左タイヤのモーター（ポートFに接続、反時計回りが正）
        left_wheel = Motor(Port.F, positive_direction=Direction.COUNTERCLOCKWISE)
        # 右タイヤのモーター（ポートBに接続、時計回りが正）
        right_wheel = Motor(Port.B, positive_direction=Direction.CLOCKWISE)
        # 左リフトのモーター（ポートEに接続、時計回りが正）
        left_lift = Motor(Port.E, positive_direction=Direction.CLOCKWISE)
        # 右リフトのモーター（ポートAに接続、時計回りが正）
        right_lift = Motor(Port.A, positive_direction=Direction.CLOCKWISE)

        # 4つのモーターをまとめて返す
        return left_wheel, right_wheel, left_lift, right_lift


    # ===== Robotクラス（DriveBaseのラッパー） =====
    class Robot:
        """
        DriveBaseをラップした便利なロボットクラス

        【このクラスの特徴】
        straight(), turn(), curve() でスピードを直接指定できます。

        【使用例】
        await robot.straight(200, speed=220)       # 220mm/sで200mm前進
        await robot.turn(90, rate=300)              # 300deg/sで90度回転
        await robot.curve(200, 45, speed=150)       # 150mm/sでカーブ

        スピードを指定しない場合は、デフォルト設定が使われます。
        """

        def __init__(self, drivebase):
            """DriveBaseを受け取って初期化"""
            self._robot = drivebase

        async def straight(self, distance, speed=None, acceleration=None, timeout=None):
            """
            直進する（スピード・タイムアウト指定可能）

            【パラメータ】
            - distance: 移動距離（mm）。正の値で前進、負の値で後退
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if speed is not None or acceleration is not None:
                self._robot.settings(
                    straight_speed=(
                        speed if speed is not None else DEFAULT_STRAIGHT_SETTINGS["straight_speed"]
                    ),
                    straight_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_STRAIGHT_SETTINGS["straight_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.straight(distance, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await self._robot.straight(distance)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def turn(self, angle, rate=None, acceleration=None, timeout=None):
            """
            その場で回転する（スピード・タイムアウト指定可能）

            【パラメータ】
            - angle: 回転角度（度）。正の値で右回転、負の値で左回転
            - rate: 回転速度（deg/s）。省略時はデフォルト設定
            - acceleration: 回転加速度（deg/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if rate is not None or acceleration is not None:
                self._robot.settings(
                    turn_rate=rate if rate is not None else DEFAULT_TURN_SETTINGS["turn_rate"],
                    turn_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_TURN_SETTINGS["turn_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.turn(angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.turn(angle)

            # デフォルト設定に戻す
            if rate is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_TURN_SETTINGS)

        async def curve(self, radius, angle, speed=None, acceleration=None, timeout=None):
            """
            カーブする（スピード・タイムアウト指定可能）

            【パラメータ】
            - radius: カーブの半径（mm）
            - angle: 回転角度（度）
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定（指定があれば上書き）
            apply_curve_settings(
                self._robot.settings,
                speed if speed is not None else None,
                acceleration if acceleration is not None else None,
            )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.curve(radius, angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.curve(radius, angle)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def run_motor(self, motor, speed, angle, timeout=None):
            """
            個別のモーターを回転させる（タイムアウト指定可能）

            【パラメータ】
            - motor: 対象のモーター（left_wheel, right_wheel, left_lift, right_liftなど）
            - speed: 回転速度（deg/s）
            - angle: 回転角度（度）
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし

            【使用例】
            await robot.run_motor(right_wheel, 200, 140, timeout=1500)
            await robot.run_motor(left_lift, 300, 180)
            """
            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: motor.run_angle(speed, angle, wait=False),
                    done_fn=lambda: motor.control.done(),
                    stop_fn=motor.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await motor.run_angle(speed, angle)

        # ----- 元のDriveBaseのメソッドをそのまま使えるようにする -----
        def stop(self):
            """ロボットを停止"""
            self._robot.stop()

        def reset(self):
            """走行距離などをリセット"""
            self._robot.reset()

        def distance(self):
            """走行距離を取得"""
            return self._robot.distance()

        def settings(self, **kwargs):
            """設定を変更（元のDriveBase.settingsと同じ）"""
            self._robot.settings(**kwargs)

        def done(self):
            """現在の移動が完了したかどうか"""
            return self._robot.done()

        def use_gyro(self, use):
            """ジャイロセンサーの使用設定"""
            self._robot.use_gyro(use)

        def distance_control(self):
            """距離制御（PID設定用）"""
            return self._robot.distance_control

        def heading_control(self):
            """方向制御（PID設定用）"""
            return self._robot.heading_control


    # ===== ロボットのパラメータ（動作の設定）をする関数 =====
    def setup_robot_parameters(left_wheel, right_wheel):
        """
        ロボットの動く速度を設定する関数

        【説明】
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで定義された
        デフォルト値が自動的に適用されます。

        【返り値】
        Robotクラスのインスタンス（DriveBaseをラップしたもの）
        """

        # ----- ロボットの物理的な大きさを設定 -----
        drivebase = DriveBase(
            left_wheel,  # 左タイヤのモーター
            right_wheel,  # 右タイヤのモーター
            wheel_diameter=62,  # タイヤの直径（mm）
            axle_track=115,  # 左右のタイヤの間隔（mm）
        )

        # ----- デフォルトの速度・加速度を自動適用 -----
        drivebase.settings(**DEFAULT_STRAIGHT_SETTINGS, **DEFAULT_TURN_SETTINGS)
        print(f"✓ デフォルト設定適用: 直進={DEFAULT_STRAIGHT_SETTINGS}, 回転={DEFAULT_TURN_SETTINGS}")

        # Robotクラスでラップして返す
        return Robot(drivebase)


    # ===== PID制御の設定をする関数 =====
    def setup_pid_control(robot):
        """
        PID制御を設定する関数

        【PID制御とは？】
        ロボットをまっすぐ正確に動かすための「自動調整機能」です。

        例えば、車を運転するときに、カーブでハンドルを少しずつ調整しますよね？
        PID制御は、ロボットが自動的にこの調整をしてくれる機能です。

        【PIDの意味】
        - P (Proportional: 比例) : 目標からどれくらいズレているかに応じて調整
        - I (Integral: 積分) : 過去のズレを積み重ねて調整
        - D (Derivative: 微分) : ズレの変化の速さに応じて調整

        【2種類のPID制御】
        1. 距離制御 (DISTANCE) : 「どれくらい進むか」を正確にコントロール
        2. 方向制御 (HEADING) : 「どの方向を向くか」を正確にコントロール

        【注意】
        下の数値（KP, KI, KD）は「ゲイン」と呼ばれ、調整の強さを決めます。
        この数値を変えると、ロボットの動きが変わります。
        うまく動かない場合は、これらの数値を調整する必要があります。
        """

        # ----- 距離制御用のPIDゲイン（「進む距離」をコントロール） -----
        DISTANCE_KP = 1000  # P（比例）ゲイン: 目標との距離差に対する反応の強さ
        DISTANCE_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        DISTANCE_KD = 10  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- 方向制御用のPIDゲイン（「向き」をコントロール） -----
        HEADING_KP = 2000  # P（比例）ゲイン: 目標との角度差に対する反応の強さ
        HEADING_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        HEADING_KD = 100  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- ロボットにPIDゲインを設定 -----
        # 距離制御のPIDゲインを設定
        robot.distance_control().pid(kp=DISTANCE_KP, ki=DISTANCE_KI, kd=DISTANCE_KD)

        # 方向制御のPIDゲインを設定
        robot.heading_control().pid(kp=HEADING_KP, ki=HEADING_KI, kd=HEADING_KD)


    # ===== センサーを初期化する関数 =====
    def initialize_sensors(hub, robot):
        """
        センサーとジャイロ（方向センサー）を初期化する関数

        【説明】
        ロボットには「ジャイロセンサー」という、スマートフォンの画面回転機能と同じような
        センサーが付いています。これは「ロボットがどちらを向いているか」を測定します。

        【やること】
        1. ジャイロセンサーを使用する設定にする
        2. 方向を0度（まっすぐ）にリセット
        3. ロボットの走行距離などをリセット

        【なぜ必要？】
        プログラムを実行する前に、「今がスタート地点」だと教える必要があります。
        これをしないと、前のプログラムの影響が残ってしまいます。
        """
        robot.use_gyro(True)  # ジャイロセンサーを使う設定にする
        hub.imu.reset_heading(0)  # 方向を0度（正面）にリセット
        robot.reset()  # ロボットの走行距離や回転角度をリセット


    # ===== モーターの角度をリセットする関数 =====
    def reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift):
        """
        すべてのモーターの角度を0度にリセットする関数

        【説明】
        モーターは回転した角度を記録しています。
        例えば、タイヤが360度回転したら「1回転した」と記録されます。

        この関数は、すべてのモーターの角度を0度に戻します。
        時計の針を12時の位置に戻すようなイメージです。

        【対象モーター】
        - 左タイヤ
        - 右タイヤ
        - 左リフト（アーム）
        - 右リフト（アーム）

        【なぜ必要？】
        プログラムを実行する前に、モーターの角度をリセットしないと、
        「前回どこまで回転したか」の情報が残ってしまい、正確に動きません。
        """
        left_wheel.reset_angle(0)  # 左タイヤのモーターを0度にリセット
        right_wheel.reset_angle(0)  # 右タイヤのモーターを0度にリセット
        left_lift.reset_angle(0)  # 左リフトのモーターを0度にリセット
        right_lift.reset_angle(0)  # 右リフトのモーターを0度にリセット
        print("✓ モーター角度リセット完了: 全モーター=0°")


    # ===== ロボット全体を初期化する関数（メイン関数） =====
    def initialize_robot():
        """
        ロボットを使う準備を全部まとめて行う関数

        【説明】
        この関数は、上で定義した5つの関数をすべて実行して、
        ロボットを使えるようにします。
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで
        定義されたデフォルト値が自動的に適用されます。

        【実行する処理（順番通り）】
        1. ハブの設定
        2. モーターの設定
        3. ロボットパラメータの設定
        4. PID制御の設定
        5. センサーの初期化
        6. モーター角度のリセット

        【返り値（戻ってくる値）】
        この関数は、以下の6つの情報を返します：
        - hub : ハブ（ロボットの脳みそ）
        - robot : ロボット全体のオブジェクト
        - left_wheel : 左タイヤのモーター
        - right_wheel : 右タイヤのモーター
        - left_lift : 左リフトのモーター
        - right_lift : 右リフトのモーター

        【使い方の例】
        他のプログラムから以下のように使います：
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        """
        print("=== ロボット初期化開始 ===")

        # ----- ステップ1: ハブの設定 -----
        hub = setup_hub()
        print("✓ ハブ設定完了")

        # ----- ステップ2: モーターの設定 -----
        left_wheel, right_wheel, left_lift, right_lift = setup_motors()
        print("✓ モーター設定完了")

        # ----- ステップ3: ロボットパラメータの設定 -----
        robot = setup_robot_parameters(left_wheel, right_wheel)
        print("✓ ロボットパラメータ設定完了")

        # ----- ステップ4: PID制御の設定 -----
        setup_pid_control(robot)
        print("✓ PID制御設定完了")

        # ----- ステップ5: センサーの初期化 -----
        initialize_sensors(hub, robot)
        print("✓ センサー初期化完了")

        # ----- ステップ6: モーター角度のリセット -----
        reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift)

        print("=== ロボット初期化完了 ===")

        # ----- すべての設定情報を返す -----
        return hub, robot, left_wheel, right_wheel, left_lift, right_lift
    # ---- main ----
    from pybricks.tools import StopWatch, wait, multitask, run_task
    _variant_m10_m11 = m10_m11

    CURRENT_MISSION = None
    ACTIVE_VARIANT = "m10_m11"
    VARIANTS = {"m10_m11": _variant_m10_m11}


    async def run_with_timing(label, coro_fn):
        timer = StopWatch()
        timer.reset()
        print(f"[RUN] {label} start")
        result = await coro_fn()
        elapsed_ms = timer.time()
        print(f"[RUN] {label} done ({elapsed_ms:.0f} ms)")
        return result


    def get_active_variant_name():
        if isinstance(CURRENT_MISSION, str) and CURRENT_MISSION in VARIANTS:
            return CURRENT_MISSION
        for name, variant in VARIANTS.items():
            if getattr(variant, "IS_CURRENT", False):
                return name
        return ACTIVE_VARIANT


    def load_variant():
        name = get_active_variant_name()
        return name, VARIANTS[name]


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        variant_name, variant = load_variant()
        label = f"run03:{variant_name}"
        return await run_with_timing(
            label,
            lambda: variant.run(
                hub,
                robot,
                left_wheel,
                right_wheel,
                left_lift,
                right_lift,
            ),
        )


    def main(hub=None, robot=None, left_wheel=None, right_wheel=None, left_lift=None, right_lift=None):
        if hub is None:
            hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        variant_name, variant = load_variant()
        label = f"run03:{variant_name}"

        async def timed_run():
            await run_with_timing(
                label,
                lambda: variant.run(
                    hub,
                    robot,
                    left_wheel,
                    right_wheel,
                    left_lift,
                    right_lift,
                ),
            )

        if hasattr(variant, "sensor_logger_task"):
            if "stop_logging" in globals():

                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)

                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        wrapped_run(),
                    )
                )
            else:
                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        timed_run(),
                    )
                )
        else:
            run_task(timed_run())
    # ---- run entry ----
    async def _run_entry(ctx):
        variant = load_variant()
        has_stop_logging = "stop_logging" in globals()
        async def timed_run():
            await run(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel, ctx.left_lift, ctx.right_lift)
        if hasattr(variant, "sensor_logger_task"):
            if has_stop_logging:
                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), wrapped_run())
            else:
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), timed_run())
        else:
            await timed_run()
    return RunBundle(initialize_robot, _run_entry)

def _make_run04():
    # Auto-generated from run04
    global stop_logging
    # ---- mission: m12 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        """ラン4: M12"""
        # ステップ1: 目標地点に向かって前進
        await robot.straight(350)

        # ステップ2: 位置調整のため少し後退
        await robot.straight(-130)

        # ステップ3: カーブしながら前進（タイムアウト処理付き）
        await robot.curve(850, 25, speed=200, timeout=2000)

        # ステップ4: スタート地点に向けて後退
        await robot.straight(-550, speed=350)

        robot.stop()
        print("# 走行完了！")


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的にターミナルに表示する非同期タスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        logger_timer = StopWatch()
        logger_timer.reset()

        while not stop_logging:
            elapsed_time = logger_timer.time()
            heading = hub.imu.heading()
            left_deg = left_wheel.angle()
            right_deg = right_wheel.angle()
            dist = robot.distance()
            print(
                f"LOG[{elapsed_time:5.0f}ms]: dist={dist:4.0f} mm  heading={heading:4.0f}°  L={left_deg:5.0f}°  R={right_deg:5.0f}°"
            )
            await wait(200)

        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    m12 = _MissionModule()
    try:
        m12.main = main
    except NameError:
        pass
    try:
        m12.run = run
    except NameError:
        pass
    try:
        m12.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        m12.stop_logging = stop_logging
    except NameError:
        pass
    # ---- setup ----
    """
    【ロボット初期化ファイル】
    このファイルは、ロボットを使い始める前に必要な「準備作業」をまとめたものです。
    料理を始める前に、材料を並べたり、調理器具を準備するのと同じように、
    ロボットもプログラムを動かす前に、モーターやセンサーの設定が必要です。

    【このファイルでやること】
    1. ハブ（ロボットの脳みそ）の向きを設定
    2. モーター（タイヤやアームを動かす装置）の設定
    3. ロボットの速度やパワーの設定
    4. PID制御（ロボットをまっすぐ動かすための調整機能）の設定
    5. センサーの初期化

    【使い方】
    他のプログラムから「initialize_robot()」という関数を呼ぶだけで、
    すべての準備が自動的に完了します。
    """

    # ===== ライブラリのインポート =====
    # LEGOロボットを動かすために必要な道具を読み込みます
    from pybricks.hubs import PrimeHub  # ロボットの「脳みそ」（ハブ）を使うための道具
    from pybricks.parameters import Axis, Direction, Port  # ポート、軸、方向などの設定
    from pybricks.pupdevices import Motor  # モーターを使うための道具
    from pybricks.robotics import DriveBase  # ロボットの移動機能を使うための道具
    from pybricks.tools import StopWatch, wait

    # ===== デフォルトの速度・加速度設定 =====
    # 各runファイルから共通で使用できる設定値

    # 直進時の設定
    DEFAULT_STRAIGHT_SETTINGS = {"straight_speed": 400, "straight_acceleration": 500}

    # 回転時の設定
    DEFAULT_TURN_SETTINGS = {"turn_rate": 240, "turn_acceleration": 850}

    # カーブ時の設定
    DEFAULT_CURVE_SETTINGS = {"straight_speed": 240, "straight_acceleration": 800}


    async def run_with_timeout(start_fn, done_fn, stop_fn, timeout_ms, poll_ms=10):
        """
        非同期ループで完了を監視し、タイムアウトで停止する共通関数。
        """
        start_fn()
        timer = StopWatch()
        timer.reset()

        while timer.time() < timeout_ms:
            if done_fn():
                return True
            await wait(poll_ms)

        stop_fn()
        return False


    def apply_curve_settings(set_settings_fn, speed=None, acceleration=None):
        """
        カーブ用の速度・加速度設定を適用するユーティリティ。
        """
        params = {}
        if speed is not None:
            params["straight_speed"] = speed
        if acceleration is not None:
            params["straight_acceleration"] = acceleration
        if params:
            set_settings_fn(**params)


    # ===== ハブの設定をする関数 =====
    def setup_hub():
        """
        ハブ（ロボットの脳みそ）の向きを設定する関数

        【説明】
        ハブには「どちらが上か」「どちらが前か」を教える必要があります。
        これを正しく設定しないと、ロボットが正しく動きません。

        【設定内容】
        - top_side=Axis.Z : Z軸が上向き
        - front_side=Axis.X : X軸が前向き
        """
        return PrimeHub(top_side=Axis.Z, front_side=Axis.X)


    # ===== モーターの設定をする関数 =====
    def setup_motors():
        """
        4つのモーター（左右のタイヤ、左右のリフト）を設定する関数

        【説明】
        ロボットには4つのモーターがあります：
        1. 左のタイヤ用モーター
        2. 右のタイヤ用モーター
        3. 左のリフト（アーム）用モーター
        4. 右のリフト（アーム）用モーター

        それぞれのモーターがどのポート（差し込み口）に接続されているか、
        どちらの方向を「正」とするかを設定します。

        【ポートの接続】
        - Port.F : 左タイヤ（反時計回りが正の方向）
        - Port.B : 右タイヤ（時計回りが正の方向）
        - Port.E : 左リフト（時計回りが正の方向）
        - Port.A : 右リフト（時計回りが正の方向）
        """
        # 左タイヤのモーター（ポートFに接続、反時計回りが正）
        left_wheel = Motor(Port.F, positive_direction=Direction.COUNTERCLOCKWISE)
        # 右タイヤのモーター（ポートBに接続、時計回りが正）
        right_wheel = Motor(Port.B, positive_direction=Direction.CLOCKWISE)
        # 左リフトのモーター（ポートEに接続、時計回りが正）
        left_lift = Motor(Port.E, positive_direction=Direction.CLOCKWISE)
        # 右リフトのモーター（ポートAに接続、時計回りが正）
        right_lift = Motor(Port.A, positive_direction=Direction.CLOCKWISE)

        # 4つのモーターをまとめて返す
        return left_wheel, right_wheel, left_lift, right_lift


    # ===== Robotクラス（DriveBaseのラッパー） =====
    class Robot:
        """
        DriveBaseをラップした便利なロボットクラス

        【このクラスの特徴】
        straight(), turn(), curve() でスピードを直接指定できます。

        【使用例】
        await robot.straight(200, speed=220)       # 220mm/sで200mm前進
        await robot.turn(90, rate=300)              # 300deg/sで90度回転
        await robot.curve(200, 45, speed=150)       # 150mm/sでカーブ

        スピードを指定しない場合は、デフォルト設定が使われます。
        """

        def __init__(self, drivebase):
            """DriveBaseを受け取って初期化"""
            self._robot = drivebase

        async def straight(self, distance, speed=None, acceleration=None, timeout=None):
            """
            直進する（スピード・タイムアウト指定可能）

            【パラメータ】
            - distance: 移動距離（mm）。正の値で前進、負の値で後退
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if speed is not None or acceleration is not None:
                self._robot.settings(
                    straight_speed=(
                        speed if speed is not None else DEFAULT_STRAIGHT_SETTINGS["straight_speed"]
                    ),
                    straight_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_STRAIGHT_SETTINGS["straight_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.straight(distance, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await self._robot.straight(distance)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def turn(self, angle, rate=None, acceleration=None, timeout=None):
            """
            その場で回転する（スピード・タイムアウト指定可能）

            【パラメータ】
            - angle: 回転角度（度）。正の値で右回転、負の値で左回転
            - rate: 回転速度（deg/s）。省略時はデフォルト設定
            - acceleration: 回転加速度（deg/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if rate is not None or acceleration is not None:
                self._robot.settings(
                    turn_rate=rate if rate is not None else DEFAULT_TURN_SETTINGS["turn_rate"],
                    turn_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_TURN_SETTINGS["turn_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.turn(angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.turn(angle)

            # デフォルト設定に戻す
            if rate is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_TURN_SETTINGS)

        async def curve(self, radius, angle, speed=None, acceleration=None, timeout=None):
            """
            カーブする（スピード・タイムアウト指定可能）

            【パラメータ】
            - radius: カーブの半径（mm）
            - angle: 回転角度（度）
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定（指定があれば上書き）
            apply_curve_settings(
                self._robot.settings,
                speed if speed is not None else None,
                acceleration if acceleration is not None else None,
            )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.curve(radius, angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.curve(radius, angle)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def run_motor(self, motor, speed, angle, timeout=None):
            """
            個別のモーターを回転させる（タイムアウト指定可能）

            【パラメータ】
            - motor: 対象のモーター（left_wheel, right_wheel, left_lift, right_liftなど）
            - speed: 回転速度（deg/s）
            - angle: 回転角度（度）
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし

            【使用例】
            await robot.run_motor(right_wheel, 200, 140, timeout=1500)
            await robot.run_motor(left_lift, 300, 180)
            """
            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: motor.run_angle(speed, angle, wait=False),
                    done_fn=lambda: motor.control.done(),
                    stop_fn=motor.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await motor.run_angle(speed, angle)

        # ----- 元のDriveBaseのメソッドをそのまま使えるようにする -----
        def stop(self):
            """ロボットを停止"""
            self._robot.stop()

        def reset(self):
            """走行距離などをリセット"""
            self._robot.reset()

        def distance(self):
            """走行距離を取得"""
            return self._robot.distance()

        def settings(self, **kwargs):
            """設定を変更（元のDriveBase.settingsと同じ）"""
            self._robot.settings(**kwargs)

        def done(self):
            """現在の移動が完了したかどうか"""
            return self._robot.done()

        def use_gyro(self, use):
            """ジャイロセンサーの使用設定"""
            self._robot.use_gyro(use)

        def distance_control(self):
            """距離制御（PID設定用）"""
            return self._robot.distance_control

        def heading_control(self):
            """方向制御（PID設定用）"""
            return self._robot.heading_control


    # ===== ロボットのパラメータ（動作の設定）をする関数 =====
    def setup_robot_parameters(left_wheel, right_wheel):
        """
        ロボットの動く速度を設定する関数

        【説明】
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで定義された
        デフォルト値が自動的に適用されます。

        【返り値】
        Robotクラスのインスタンス（DriveBaseをラップしたもの）
        """

        # ----- ロボットの物理的な大きさを設定 -----
        drivebase = DriveBase(
            left_wheel,  # 左タイヤのモーター
            right_wheel,  # 右タイヤのモーター
            wheel_diameter=62,  # タイヤの直径（mm）
            axle_track=115,  # 左右のタイヤの間隔（mm）
        )

        # ----- デフォルトの速度・加速度を自動適用 -----
        drivebase.settings(**DEFAULT_STRAIGHT_SETTINGS, **DEFAULT_TURN_SETTINGS)
        print(f"✓ デフォルト設定適用: 直進={DEFAULT_STRAIGHT_SETTINGS}, 回転={DEFAULT_TURN_SETTINGS}")

        # Robotクラスでラップして返す
        return Robot(drivebase)


    # ===== PID制御の設定をする関数 =====
    def setup_pid_control(robot):
        """
        PID制御を設定する関数

        【PID制御とは？】
        ロボットをまっすぐ正確に動かすための「自動調整機能」です。

        例えば、車を運転するときに、カーブでハンドルを少しずつ調整しますよね？
        PID制御は、ロボットが自動的にこの調整をしてくれる機能です。

        【PIDの意味】
        - P (Proportional: 比例) : 目標からどれくらいズレているかに応じて調整
        - I (Integral: 積分) : 過去のズレを積み重ねて調整
        - D (Derivative: 微分) : ズレの変化の速さに応じて調整

        【2種類のPID制御】
        1. 距離制御 (DISTANCE) : 「どれくらい進むか」を正確にコントロール
        2. 方向制御 (HEADING) : 「どの方向を向くか」を正確にコントロール

        【注意】
        下の数値（KP, KI, KD）は「ゲイン」と呼ばれ、調整の強さを決めます。
        この数値を変えると、ロボットの動きが変わります。
        うまく動かない場合は、これらの数値を調整する必要があります。
        """

        # ----- 距離制御用のPIDゲイン（「進む距離」をコントロール） -----
        DISTANCE_KP = 1000  # P（比例）ゲイン: 目標との距離差に対する反応の強さ
        DISTANCE_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        DISTANCE_KD = 10  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- 方向制御用のPIDゲイン（「向き」をコントロール） -----
        HEADING_KP = 2000  # P（比例）ゲイン: 目標との角度差に対する反応の強さ
        HEADING_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        HEADING_KD = 100  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- ロボットにPIDゲインを設定 -----
        # 距離制御のPIDゲインを設定
        robot.distance_control().pid(kp=DISTANCE_KP, ki=DISTANCE_KI, kd=DISTANCE_KD)

        # 方向制御のPIDゲインを設定
        robot.heading_control().pid(kp=HEADING_KP, ki=HEADING_KI, kd=HEADING_KD)


    # ===== センサーを初期化する関数 =====
    def initialize_sensors(hub, robot):
        """
        センサーとジャイロ（方向センサー）を初期化する関数

        【説明】
        ロボットには「ジャイロセンサー」という、スマートフォンの画面回転機能と同じような
        センサーが付いています。これは「ロボットがどちらを向いているか」を測定します。

        【やること】
        1. ジャイロセンサーを使用する設定にする
        2. 方向を0度（まっすぐ）にリセット
        3. ロボットの走行距離などをリセット

        【なぜ必要？】
        プログラムを実行する前に、「今がスタート地点」だと教える必要があります。
        これをしないと、前のプログラムの影響が残ってしまいます。
        """
        robot.use_gyro(True)  # ジャイロセンサーを使う設定にする
        hub.imu.reset_heading(0)  # 方向を0度（正面）にリセット
        robot.reset()  # ロボットの走行距離や回転角度をリセット


    # ===== モーターの角度をリセットする関数 =====
    def reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift):
        """
        すべてのモーターの角度を0度にリセットする関数

        【説明】
        モーターは回転した角度を記録しています。
        例えば、タイヤが360度回転したら「1回転した」と記録されます。

        この関数は、すべてのモーターの角度を0度に戻します。
        時計の針を12時の位置に戻すようなイメージです。

        【対象モーター】
        - 左タイヤ
        - 右タイヤ
        - 左リフト（アーム）
        - 右リフト（アーム）

        【なぜ必要？】
        プログラムを実行する前に、モーターの角度をリセットしないと、
        「前回どこまで回転したか」の情報が残ってしまい、正確に動きません。
        """
        left_wheel.reset_angle(0)  # 左タイヤのモーターを0度にリセット
        right_wheel.reset_angle(0)  # 右タイヤのモーターを0度にリセット
        left_lift.reset_angle(0)  # 左リフトのモーターを0度にリセット
        right_lift.reset_angle(0)  # 右リフトのモーターを0度にリセット
        print("✓ モーター角度リセット完了: 全モーター=0°")


    # ===== ロボット全体を初期化する関数（メイン関数） =====
    def initialize_robot():
        """
        ロボットを使う準備を全部まとめて行う関数

        【説明】
        この関数は、上で定義した5つの関数をすべて実行して、
        ロボットを使えるようにします。
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで
        定義されたデフォルト値が自動的に適用されます。

        【実行する処理（順番通り）】
        1. ハブの設定
        2. モーターの設定
        3. ロボットパラメータの設定
        4. PID制御の設定
        5. センサーの初期化
        6. モーター角度のリセット

        【返り値（戻ってくる値）】
        この関数は、以下の6つの情報を返します：
        - hub : ハブ（ロボットの脳みそ）
        - robot : ロボット全体のオブジェクト
        - left_wheel : 左タイヤのモーター
        - right_wheel : 右タイヤのモーター
        - left_lift : 左リフトのモーター
        - right_lift : 右リフトのモーター

        【使い方の例】
        他のプログラムから以下のように使います：
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        """
        print("=== ロボット初期化開始 ===")

        # ----- ステップ1: ハブの設定 -----
        hub = setup_hub()
        print("✓ ハブ設定完了")

        # ----- ステップ2: モーターの設定 -----
        left_wheel, right_wheel, left_lift, right_lift = setup_motors()
        print("✓ モーター設定完了")

        # ----- ステップ3: ロボットパラメータの設定 -----
        robot = setup_robot_parameters(left_wheel, right_wheel)
        print("✓ ロボットパラメータ設定完了")

        # ----- ステップ4: PID制御の設定 -----
        setup_pid_control(robot)
        print("✓ PID制御設定完了")

        # ----- ステップ5: センサーの初期化 -----
        initialize_sensors(hub, robot)
        print("✓ センサー初期化完了")

        # ----- ステップ6: モーター角度のリセット -----
        reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift)

        print("=== ロボット初期化完了 ===")

        # ----- すべての設定情報を返す -----
        return hub, robot, left_wheel, right_wheel, left_lift, right_lift
    # ---- main ----
    from pybricks.tools import StopWatch, multitask, run_task, wait
    _variant_m12 = m12

    CURRENT_MISSION = None
    ACTIVE_VARIANT = "m12"
    VARIANTS = {"m12": _variant_m12}


    async def run_with_timing(label, coro_fn):
        timer = StopWatch()
        timer.reset()
        print(f"[RUN] {label} start")
        result = await coro_fn()
        elapsed_ms = timer.time()
        print(f"[RUN] {label} done ({elapsed_ms:.0f} ms)")
        return result


    def get_active_variant_name():
        if isinstance(CURRENT_MISSION, str) and CURRENT_MISSION in VARIANTS:
            return CURRENT_MISSION
        for name, variant in VARIANTS.items():
            if getattr(variant, "IS_CURRENT", False):
                return name
        return ACTIVE_VARIANT


    def load_variant():
        name = get_active_variant_name()
        return name, VARIANTS[name]


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        variant_name, variant = load_variant()
        label = f"run04:{variant_name}"
        return await run_with_timing(
            label,
            lambda: variant.run(
                hub,
                robot,
                left_wheel,
                right_wheel,
                left_lift,
                right_lift,
            ),
        )

    def main(hub=None, robot=None, left_wheel=None, right_wheel=None, left_lift=None, right_lift=None):
        if hub is None:
            hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        variant_name, variant = load_variant()
        label = f"run04:{variant_name}"

        async def timed_run():
            await run_with_timing(
                label,
                lambda: variant.run(
                    hub,
                    robot,
                    left_wheel,
                    right_wheel,
                    left_lift,
                    right_lift,
                ),
            )

        if hasattr(variant, "sensor_logger_task"):
            if "stop_logging" in globals():

                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)

                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        wrapped_run(),
                    )
                )
            else:
                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        timed_run(),
                    )
                )
        else:
            run_task(timed_run())
    # ---- run entry ----
    async def _run_entry(ctx):
        variant = load_variant()
        has_stop_logging = "stop_logging" in globals()
        async def timed_run():
            await run(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel, ctx.left_lift, ctx.right_lift)
        if hasattr(variant, "sensor_logger_task"):
            if has_stop_logging:
                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), wrapped_run())
            else:
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), timed_run())
        else:
            await timed_run()
    return RunBundle(initialize_robot, _run_entry)

def _make_run05():
    # Auto-generated from run05
    global stop_logging
    # ---- mission: m01_m02_kanna ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        """ラン5: M01, M02"""
        await robot.straight(590)  # M01に向けて前進
        await robot.straight(-120)  # M01で後進して奥側の羽を倒す
        await robot.turn(40)  # M02に向けて方向転換
        await robot.straight(220)
        await robot.turn(-85)
        await robot.straight(205, timeout=3000)
        await robot.straight(-210)
        await robot.turn(-45)
        await robot.straight(50)
        await left_lift.run_angle(300, 180)
        await robot.straight(-50)
        await robot.turn(-70)
        await robot.straight(580)

        robot.stop()
        print("# 走行完了！")


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的にターミナルに表示する非同期タスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        logger_timer = StopWatch()
        logger_timer.reset()

        print(
            "time,current_dist_mm,error_angle_deg,current_heading_deg,left_angle_deg,right_angle_deg,angle_diff_deg,"
            "left_speed_dps,right_speed_dps,speed_diff_dps,kp_dist,ki_dist,kd_dist,kp_head,ki_head,kd_head"
        )

        while not stop_logging:
            elapsed_time = logger_timer.time()
            current_dist_mm = robot.distance()
            current_heading_deg = hub.imu.heading()
            left_angle_deg = left_wheel.angle()
            right_angle_deg = right_wheel.angle()
            angle_diff_deg = right_angle_deg - left_angle_deg
            left_speed_dps = left_wheel.speed()
            right_speed_dps = right_wheel.speed()
            speed_diff_dps = right_speed_dps - left_speed_dps

            kp_dist = 1000
            ki_dist = 50
            kd_dist = 10
            kp_head = 2000
            ki_head = 50
            kd_head = 100
            error_angle_deg = 0

            print(
                f"{elapsed_time:.0f},{current_dist_mm:.1f},{error_angle_deg:.1f},{current_heading_deg:.1f},{left_angle_deg:.1f},{right_angle_deg:.1f},{angle_diff_deg:.1f},{left_speed_dps:.1f},{right_speed_dps:.1f},{speed_diff_dps:.1f},{kp_dist:.1f},{ki_dist:.1f},{kd_dist:.1f},{kp_head:.1f},{ki_head:.1f},{kd_head:.1f}"
            )

            await wait(200)

        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    m01_m02_kanna = _MissionModule()
    try:
        m01_m02_kanna.main = main
    except NameError:
        pass
    try:
        m01_m02_kanna.run = run
    except NameError:
        pass
    try:
        m01_m02_kanna.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        m01_m02_kanna.stop_logging = stop_logging
    except NameError:
        pass
    # ---- setup ----
    """
    【ロボット初期化ファイル】
    このファイルは、ロボットを使い始める前に必要な「準備作業」をまとめたものです。
    料理を始める前に、材料を並べたり、調理器具を準備するのと同じように、
    ロボットもプログラムを動かす前に、モーターやセンサーの設定が必要です。

    【このファイルでやること】
    1. ハブ（ロボットの脳みそ）の向きを設定
    2. モーター（タイヤやアームを動かす装置）の設定
    3. ロボットの速度やパワーの設定
    4. PID制御（ロボットをまっすぐ動かすための調整機能）の設定
    5. センサーの初期化

    【使い方】
    他のプログラムから「initialize_robot()」という関数を呼ぶだけで、
    すべての準備が自動的に完了します。
    """

    # ===== ライブラリのインポート =====
    # LEGOロボットを動かすために必要な道具を読み込みます
    from pybricks.hubs import PrimeHub  # ロボットの「脳みそ」（ハブ）を使うための道具
    from pybricks.parameters import Axis, Direction, Port  # ポート、軸、方向などの設定
    from pybricks.pupdevices import Motor  # モーターを使うための道具
    from pybricks.robotics import DriveBase  # ロボットの移動機能を使うための道具
    from pybricks.tools import StopWatch, wait

    # ===== デフォルトの速度・加速度設定 =====
    # 各runファイルから共通で使用できる設定値

    # 直進時の設定
    DEFAULT_STRAIGHT_SETTINGS = {"straight_speed": 400, "straight_acceleration": 500}

    # 回転時の設定
    DEFAULT_TURN_SETTINGS = {"turn_rate": 240, "turn_acceleration": 850}

    # カーブ時の設定
    DEFAULT_CURVE_SETTINGS = {"straight_speed": 240, "straight_acceleration": 800}


    async def run_with_timeout(start_fn, done_fn, stop_fn, timeout_ms, poll_ms=10):
        """
        非同期ループで完了を監視し、タイムアウトで停止する共通関数。
        """
        start_fn()
        timer = StopWatch()
        timer.reset()

        while timer.time() < timeout_ms:
            if done_fn():
                return True
            await wait(poll_ms)

        stop_fn()
        return False


    def apply_curve_settings(set_settings_fn, speed=None, acceleration=None):
        """
        カーブ用の速度・加速度設定を適用するユーティリティ。
        """
        params = {}
        if speed is not None:
            params["straight_speed"] = speed
        if acceleration is not None:
            params["straight_acceleration"] = acceleration
        if params:
            set_settings_fn(**params)


    # ===== ハブの設定をする関数 =====
    def setup_hub():
        """
        ハブ（ロボットの脳みそ）の向きを設定する関数

        【説明】
        ハブには「どちらが上か」「どちらが前か」を教える必要があります。
        これを正しく設定しないと、ロボットが正しく動きません。

        【設定内容】
        - top_side=Axis.Z : Z軸が上向き
        - front_side=Axis.X : X軸が前向き
        """
        return PrimeHub(top_side=Axis.Z, front_side=Axis.X)


    # ===== モーターの設定をする関数 =====
    def setup_motors():
        """
        4つのモーター（左右のタイヤ、左右のリフト）を設定する関数

        【説明】
        ロボットには4つのモーターがあります：
        1. 左のタイヤ用モーター
        2. 右のタイヤ用モーター
        3. 左のリフト（アーム）用モーター
        4. 右のリフト（アーム）用モーター

        それぞれのモーターがどのポート（差し込み口）に接続されているか、
        どちらの方向を「正」とするかを設定します。

        【ポートの接続】
        - Port.F : 左タイヤ（反時計回りが正の方向）
        - Port.B : 右タイヤ（時計回りが正の方向）
        - Port.E : 左リフト（時計回りが正の方向）
        - Port.A : 右リフト（時計回りが正の方向）
        """
        # 左タイヤのモーター（ポートFに接続、反時計回りが正）
        left_wheel = Motor(Port.F, positive_direction=Direction.COUNTERCLOCKWISE)
        # 右タイヤのモーター（ポートBに接続、時計回りが正）
        right_wheel = Motor(Port.B, positive_direction=Direction.CLOCKWISE)
        # 左リフトのモーター（ポートEに接続、時計回りが正）
        left_lift = Motor(Port.E, positive_direction=Direction.CLOCKWISE)
        # 右リフトのモーター（ポートAに接続、時計回りが正）
        right_lift = Motor(Port.A, positive_direction=Direction.CLOCKWISE)

        # 4つのモーターをまとめて返す
        return left_wheel, right_wheel, left_lift, right_lift


    # ===== Robotクラス（DriveBaseのラッパー） =====
    class Robot:
        """
        DriveBaseをラップした便利なロボットクラス

        【このクラスの特徴】
        straight(), turn(), curve() でスピードを直接指定できます。

        【使用例】
        await robot.straight(200, speed=220)       # 220mm/sで200mm前進
        await robot.turn(90, rate=300)              # 300deg/sで90度回転
        await robot.curve(200, 45, speed=150)       # 150mm/sでカーブ

        スピードを指定しない場合は、デフォルト設定が使われます。
        """

        def __init__(self, drivebase):
            """DriveBaseを受け取って初期化"""
            self._robot = drivebase

        async def straight(self, distance, speed=None, acceleration=None, timeout=None):
            """
            直進する（スピード・タイムアウト指定可能）

            【パラメータ】
            - distance: 移動距離（mm）。正の値で前進、負の値で後退
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if speed is not None or acceleration is not None:
                self._robot.settings(
                    straight_speed=(
                        speed if speed is not None else DEFAULT_STRAIGHT_SETTINGS["straight_speed"]
                    ),
                    straight_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_STRAIGHT_SETTINGS["straight_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.straight(distance, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await self._robot.straight(distance)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def turn(self, angle, rate=None, acceleration=None, timeout=None):
            """
            その場で回転する（スピード・タイムアウト指定可能）

            【パラメータ】
            - angle: 回転角度（度）。正の値で右回転、負の値で左回転
            - rate: 回転速度（deg/s）。省略時はデフォルト設定
            - acceleration: 回転加速度（deg/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if rate is not None or acceleration is not None:
                self._robot.settings(
                    turn_rate=rate if rate is not None else DEFAULT_TURN_SETTINGS["turn_rate"],
                    turn_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_TURN_SETTINGS["turn_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.turn(angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.turn(angle)

            # デフォルト設定に戻す
            if rate is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_TURN_SETTINGS)

        async def curve(self, radius, angle, speed=None, acceleration=None, timeout=None):
            """
            カーブする（スピード・タイムアウト指定可能）

            【パラメータ】
            - radius: カーブの半径（mm）
            - angle: 回転角度（度）
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定（指定があれば上書き）
            apply_curve_settings(
                self._robot.settings,
                speed if speed is not None else None,
                acceleration if acceleration is not None else None,
            )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.curve(radius, angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.curve(radius, angle)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def run_motor(self, motor, speed, angle, timeout=None):
            """
            個別のモーターを回転させる（タイムアウト指定可能）

            【パラメータ】
            - motor: 対象のモーター（left_wheel, right_wheel, left_lift, right_liftなど）
            - speed: 回転速度（deg/s）
            - angle: 回転角度（度）
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし

            【使用例】
            await robot.run_motor(right_wheel, 200, 140, timeout=1500)
            await robot.run_motor(left_lift, 300, 180)
            """
            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: motor.run_angle(speed, angle, wait=False),
                    done_fn=lambda: motor.control.done(),
                    stop_fn=motor.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await motor.run_angle(speed, angle)

        # ----- 元のDriveBaseのメソッドをそのまま使えるようにする -----
        def stop(self):
            """ロボットを停止"""
            self._robot.stop()

        def reset(self):
            """走行距離などをリセット"""
            self._robot.reset()

        def distance(self):
            """走行距離を取得"""
            return self._robot.distance()

        def settings(self, **kwargs):
            """設定を変更（元のDriveBase.settingsと同じ）"""
            self._robot.settings(**kwargs)

        def done(self):
            """現在の移動が完了したかどうか"""
            return self._robot.done()

        def use_gyro(self, use):
            """ジャイロセンサーの使用設定"""
            self._robot.use_gyro(use)

        def distance_control(self):
            """距離制御（PID設定用）"""
            return self._robot.distance_control

        def heading_control(self):
            """方向制御（PID設定用）"""
            return self._robot.heading_control


    # ===== ロボットのパラメータ（動作の設定）をする関数 =====
    def setup_robot_parameters(left_wheel, right_wheel):
        """
        ロボットの動く速度を設定する関数

        【説明】
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで定義された
        デフォルト値が自動的に適用されます。

        【返り値】
        Robotクラスのインスタンス（DriveBaseをラップしたもの）
        """

        # ----- ロボットの物理的な大きさを設定 -----
        drivebase = DriveBase(
            left_wheel,  # 左タイヤのモーター
            right_wheel,  # 右タイヤのモーター
            wheel_diameter=62,  # タイヤの直径（mm）
            axle_track=115,  # 左右のタイヤの間隔（mm）
        )

        # ----- デフォルトの速度・加速度を自動適用 -----
        drivebase.settings(**DEFAULT_STRAIGHT_SETTINGS, **DEFAULT_TURN_SETTINGS)
        print(f"✓ デフォルト設定適用: 直進={DEFAULT_STRAIGHT_SETTINGS}, 回転={DEFAULT_TURN_SETTINGS}")

        # Robotクラスでラップして返す
        return Robot(drivebase)


    # ===== PID制御の設定をする関数 =====
    def setup_pid_control(robot):
        """
        PID制御を設定する関数

        【PID制御とは？】
        ロボットをまっすぐ正確に動かすための「自動調整機能」です。

        例えば、車を運転するときに、カーブでハンドルを少しずつ調整しますよね？
        PID制御は、ロボットが自動的にこの調整をしてくれる機能です。

        【PIDの意味】
        - P (Proportional: 比例) : 目標からどれくらいズレているかに応じて調整
        - I (Integral: 積分) : 過去のズレを積み重ねて調整
        - D (Derivative: 微分) : ズレの変化の速さに応じて調整

        【2種類のPID制御】
        1. 距離制御 (DISTANCE) : 「どれくらい進むか」を正確にコントロール
        2. 方向制御 (HEADING) : 「どの方向を向くか」を正確にコントロール

        【注意】
        下の数値（KP, KI, KD）は「ゲイン」と呼ばれ、調整の強さを決めます。
        この数値を変えると、ロボットの動きが変わります。
        うまく動かない場合は、これらの数値を調整する必要があります。
        """

        # ----- 距離制御用のPIDゲイン（「進む距離」をコントロール） -----
        DISTANCE_KP = 1000  # P（比例）ゲイン: 目標との距離差に対する反応の強さ
        DISTANCE_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        DISTANCE_KD = 10  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- 方向制御用のPIDゲイン（「向き」をコントロール） -----
        HEADING_KP = 2000  # P（比例）ゲイン: 目標との角度差に対する反応の強さ
        HEADING_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        HEADING_KD = 100  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- ロボットにPIDゲインを設定 -----
        # 距離制御のPIDゲインを設定
        robot.distance_control().pid(kp=DISTANCE_KP, ki=DISTANCE_KI, kd=DISTANCE_KD)

        # 方向制御のPIDゲインを設定
        robot.heading_control().pid(kp=HEADING_KP, ki=HEADING_KI, kd=HEADING_KD)


    # ===== センサーを初期化する関数 =====
    def initialize_sensors(hub, robot):
        """
        センサーとジャイロ（方向センサー）を初期化する関数

        【説明】
        ロボットには「ジャイロセンサー」という、スマートフォンの画面回転機能と同じような
        センサーが付いています。これは「ロボットがどちらを向いているか」を測定します。

        【やること】
        1. ジャイロセンサーを使用する設定にする
        2. 方向を0度（まっすぐ）にリセット
        3. ロボットの走行距離などをリセット

        【なぜ必要？】
        プログラムを実行する前に、「今がスタート地点」だと教える必要があります。
        これをしないと、前のプログラムの影響が残ってしまいます。
        """
        robot.use_gyro(True)  # ジャイロセンサーを使う設定にする
        hub.imu.reset_heading(0)  # 方向を0度（正面）にリセット
        robot.reset()  # ロボットの走行距離や回転角度をリセット


    # ===== モーターの角度をリセットする関数 =====
    def reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift):
        """
        すべてのモーターの角度を0度にリセットする関数

        【説明】
        モーターは回転した角度を記録しています。
        例えば、タイヤが360度回転したら「1回転した」と記録されます。

        この関数は、すべてのモーターの角度を0度に戻します。
        時計の針を12時の位置に戻すようなイメージです。

        【対象モーター】
        - 左タイヤ
        - 右タイヤ
        - 左リフト（アーム）
        - 右リフト（アーム）

        【なぜ必要？】
        プログラムを実行する前に、モーターの角度をリセットしないと、
        「前回どこまで回転したか」の情報が残ってしまい、正確に動きません。
        """
        left_wheel.reset_angle(0)  # 左タイヤのモーターを0度にリセット
        right_wheel.reset_angle(0)  # 右タイヤのモーターを0度にリセット
        left_lift.reset_angle(0)  # 左リフトのモーターを0度にリセット
        right_lift.reset_angle(0)  # 右リフトのモーターを0度にリセット
        print("✓ モーター角度リセット完了: 全モーター=0°")


    # ===== ロボット全体を初期化する関数（メイン関数） =====
    def initialize_robot():
        """
        ロボットを使う準備を全部まとめて行う関数

        【説明】
        この関数は、上で定義した5つの関数をすべて実行して、
        ロボットを使えるようにします。
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで
        定義されたデフォルト値が自動的に適用されます。

        【実行する処理（順番通り）】
        1. ハブの設定
        2. モーターの設定
        3. ロボットパラメータの設定
        4. PID制御の設定
        5. センサーの初期化
        6. モーター角度のリセット

        【返り値（戻ってくる値）】
        この関数は、以下の6つの情報を返します：
        - hub : ハブ（ロボットの脳みそ）
        - robot : ロボット全体のオブジェクト
        - left_wheel : 左タイヤのモーター
        - right_wheel : 右タイヤのモーター
        - left_lift : 左リフトのモーター
        - right_lift : 右リフトのモーター

        【使い方の例】
        他のプログラムから以下のように使います：
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        """
        print("=== ロボット初期化開始 ===")

        # ----- ステップ1: ハブの設定 -----
        hub = setup_hub()
        print("✓ ハブ設定完了")

        # ----- ステップ2: モーターの設定 -----
        left_wheel, right_wheel, left_lift, right_lift = setup_motors()
        print("✓ モーター設定完了")

        # ----- ステップ3: ロボットパラメータの設定 -----
        robot = setup_robot_parameters(left_wheel, right_wheel)
        print("✓ ロボットパラメータ設定完了")

        # ----- ステップ4: PID制御の設定 -----
        setup_pid_control(robot)
        print("✓ PID制御設定完了")

        # ----- ステップ5: センサーの初期化 -----
        initialize_sensors(hub, robot)
        print("✓ センサー初期化完了")

        # ----- ステップ6: モーター角度のリセット -----
        reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift)

        print("=== ロボット初期化完了 ===")

        # ----- すべての設定情報を返す -----
        return hub, robot, left_wheel, right_wheel, left_lift, right_lift
    # ---- main ----
    from pybricks.tools import StopWatch, multitask, run_task, wait
    _variant_m01_m02_kanna = m01_m02_kanna

    CURRENT_MISSION = None
    ACTIVE_VARIANT = "m01_m02_kanna"
    VARIANTS = {"m01_m02_kanna": _variant_m01_m02_kanna}


    async def run_with_timing(label, coro_fn):
        timer = StopWatch()
        timer.reset()
        print(f"[RUN] {label} start")
        result = await coro_fn()
        elapsed_ms = timer.time()
        print(f"[RUN] {label} done ({elapsed_ms:.0f} ms)")
        return result


    def get_active_variant_name():
        if isinstance(CURRENT_MISSION, str) and CURRENT_MISSION in VARIANTS:
            return CURRENT_MISSION
        for name, variant in VARIANTS.items():
            if getattr(variant, "IS_CURRENT", False):
                return name
        return ACTIVE_VARIANT


    def load_variant():
        name = get_active_variant_name()
        return name, VARIANTS[name]


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        variant_name, variant = load_variant()
        label = f"run05:{variant_name}"
        return await run_with_timing(
            label,
            lambda: variant.run(
                hub,
                robot,
                left_wheel,
                right_wheel,
                left_lift,
                right_lift,
            ),
        )

    def main(hub=None, robot=None, left_wheel=None, right_wheel=None, left_lift=None, right_lift=None):
        if hub is None:
            hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        variant_name, variant = load_variant()
        label = f"run05:{variant_name}"

        async def timed_run():
            await run_with_timing(
                label,
                lambda: variant.run(
                    hub,
                    robot,
                    left_wheel,
                    right_wheel,
                    left_lift,
                    right_lift,
                ),
            )

        if hasattr(variant, "sensor_logger_task"):
            if "stop_logging" in globals():

                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)

                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        wrapped_run(),
                    )
                )
            else:
                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        timed_run(),
                    )
                )
        else:
            run_task(timed_run())
    # ---- run entry ----
    async def _run_entry(ctx):
        variant = load_variant()
        has_stop_logging = "stop_logging" in globals()
        async def timed_run():
            await run(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel, ctx.left_lift, ctx.right_lift)
        if hasattr(variant, "sensor_logger_task"):
            if has_stop_logging:
                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), wrapped_run())
            else:
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), timed_run())
        else:
            await timed_run()
    return RunBundle(initialize_robot, _run_entry)

def _make_run06():
    # Auto-generated from run06
    global stop_logging
    # ---- mission: M03_M04 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
    #######################################
        # ここにロボットの動作を記述してください

        # 作業位置まで前進（55cm）
        await robot.straight(400)
        # 右に90度回転
        await robot.turn(35)
        await robot.straight(200)
        await robot.turn(-35)
        await robot.straight(270)
        await robot.turn(75)
        # 左アームを下げる
        await left_lift.run_angle(800, 2000)
        # 右アームを下げる
        # await right_lift.run_angle(800, -2000)

        await robot.straight(100)
        # 右アームを上げる
        # await right_lift.run_angle(800, 2000)
        # 回転後に前進（10cm）
        # await robot.straight(100)

        # # 作業位置まで前進（10cm）
        # await robot.straight(100)

        # # 左アームを上げる
        # await left_lift.run_angle(500, -100)
        # # 右アームを上げる
        # await right_lift.run_angle(500, 1000)

        # # 元の位置に戻る（10cm）
        # await robot.straight(-100)
        
        # await left_lift.run_angle(500, 1200)

        # 走行終了
        robot.stop()
        print("# 走行完了！")
    ##########################################


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的にターミナルに表示する非同期タスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        logger_timer = StopWatch()
        logger_timer.reset()

        while not stop_logging:
            elapsed_time = logger_timer.time()
            heading = hub.imu.heading()
            left_deg = left_wheel.angle()
            right_deg = right_wheel.angle()
            dist = robot.distance()
            print(
                f"LOG[{elapsed_time:5.0f}ms]: dist={dist:4.0f} mm  heading={heading:4.0f}°  L={left_deg:5.0f}°  R={right_deg:5.0f}°"
            )
            await wait(200)

        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    M03_M04 = _MissionModule()
    try:
        M03_M04.main = main
    except NameError:
        pass
    try:
        M03_M04.run = run
    except NameError:
        pass
    try:
        M03_M04.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        M03_M04.stop_logging = stop_logging
    except NameError:
        pass
    # ---- mission: M03_M04_ayumu_01_30 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    stop_logging = False
    IS_CURRENT = True


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
    #######################################
        # ここにロボットの動作を記述してください

        # 作業位置まで前進（55cm）
        await robot.straight(400)
        # 右に90度回転
        await robot.turn(35)
        await robot.straight(200)
        await robot.turn(-35)
        await robot.straight(270)
        await robot.turn(75)
        # 左アームを下げる
        await left_lift.run_angle(800, 2000)
        # 右アームを下げる
        # await right_lift.run_angle(800, -2000)

        await robot.straight(100)
        # 右アームを上げる
        # await right_lift.run_angle(800, 2000)
        # 回転後に前進（10cm）
        # await robot.straight(100)

        # # 作業位置まで前進（10cm）
        # await robot.straight(100)

        # # 左アームを上げる
        # await left_lift.run_angle(500, -100)
        # # 右アームを上げる
        # await right_lift.run_angle(500, 1000)

        # # 元の位置に戻る（10cm）
        # await robot.straight(-100)
        
        # await left_lift.run_angle(500, 1200)

        # 走行終了
        robot.stop()
        print("# 走行完了！")
    ##########################################


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的にターミナルに表示する非同期タスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        logger_timer = StopWatch()
        logger_timer.reset()

        while not stop_logging:
            elapsed_time = logger_timer.time()
            heading = hub.imu.heading()
            left_deg = left_wheel.angle()
            right_deg = right_wheel.angle()
            dist = robot.distance()
            print(
                f"LOG[{elapsed_time:5.0f}ms]: dist={dist:4.0f} mm  heading={heading:4.0f}°  L={left_deg:5.0f}°  R={right_deg:5.0f}°"
            )
            await wait(200)

        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    M03_M04_ayumu_01_30 = _MissionModule()
    try:
        M03_M04_ayumu_01_30.IS_CURRENT = IS_CURRENT
    except NameError:
        pass
    try:
        M03_M04_ayumu_01_30.main = main
    except NameError:
        pass
    try:
        M03_M04_ayumu_01_30.run = run
    except NameError:
        pass
    try:
        M03_M04_ayumu_01_30.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        M03_M04_ayumu_01_30.stop_logging = stop_logging
    except NameError:
        pass
    # ---- mission: m13_m03 ----
    from pybricks.tools import StopWatch, multitask, run_task, wait

    stop_logging = False


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        """ラン6: M13, M03"""
        straight_settings = {
            "straight_speed": 400,
            "straight_acceleration": 500,
        }
        turn_settings = {
            "turn_rate": 240,
            "turn_acceleration": 850,
        }

        robot.settings(**straight_settings)
        await robot.straight(650)

        robot.settings(**turn_settings)
        await robot.turn(90)

        robot.settings(**straight_settings)
        await robot.straight(262)

        robot.settings(**turn_settings)
        await robot.turn(39)

        robot.settings(**straight_settings)
        await robot.straight(140)
        await wait(100)

        await right_lift.run_angle(150, 380)
        await wait(300)

        robot.settings(**turn_settings)
        await robot.turn(-30)
        await wait(700)

        robot.settings(**turn_settings)
        await robot.turn(30)

        robot.settings(**straight_settings)
        await robot.straight(-48)

        robot.settings(**turn_settings)
        await robot.turn(245)

        await right_lift.run_angle(1000, -350)
        await robot.straight(48)
        await right_lift.run_angle(1000, 360 * 3)
        await wait(500)
        await right_lift.run_angle(800, -50)

        robot.settings(**turn_settings)
        await robot.turn(-100)

        robot.settings(**straight_settings)
        await robot.straight(300)

        robot.settings(**turn_settings)
        await robot.turn(-80)

        robot.settings(**straight_settings)
        await robot.straight(700)

        robot.stop()
        print("# 走行完了！")


    async def sensor_logger_task(hub, robot, left_wheel, right_wheel):
        """センサー値を定期的にターミナルに表示する非同期タスク。"""
        global stop_logging
        print("--- センサーログタスク開始 ---")
        logger_timer = StopWatch()
        logger_timer.reset()

        print(
            "time,current_dist_mm,error_angle_deg,current_heading_deg,left_angle_deg,right_angle_deg,angle_diff_deg,"
            "left_speed_dps,right_speed_dps,speed_diff_dps,kp_dist,ki_dist,kd_dist,kp_head,ki_head,kd_head"
        )

        while not stop_logging:
            elapsed_time = logger_timer.time()
            current_dist_mm = robot.distance()
            current_heading_deg = hub.imu.heading()
            left_angle_deg = left_wheel.angle()
            right_angle_deg = right_wheel.angle()
            angle_diff_deg = right_angle_deg - left_angle_deg
            left_speed_dps = left_wheel.speed()
            right_speed_dps = right_wheel.speed()
            speed_diff_dps = right_speed_dps - left_speed_dps

            kp_dist = 1000
            ki_dist = 50
            kd_dist = 10
            kp_head = 2000
            ki_head = 50
            kd_head = 100

            error_angle_deg = 0

            print(
                f"{elapsed_time:.0f},{current_dist_mm:.1f},{error_angle_deg:.1f},{current_heading_deg:.1f},{left_angle_deg:.1f},{right_angle_deg:.1f},{angle_diff_deg:.1f},{left_speed_dps:.1f},{right_speed_dps:.1f},{speed_diff_dps:.1f},{kp_dist:.1f},{ki_dist:.1f},{kd_dist:.1f},{kp_head:.1f},{ki_head:.1f},{kd_head:.1f}"
            )

            await wait(200)

        print("--- センサーログタスク終了 ---")


    async def main():
        global stop_logging
        await run(hub, robot, left_wheel, right_wheel, left_lift, right_lift)
        stop_logging = True
        print("--- メインタスク完了、ログタスク終了中 ---")
        await wait(500)
    # ---- mission binding ----
    class _MissionModule:
        pass
    m13_m03 = _MissionModule()
    try:
        m13_m03.main = main
    except NameError:
        pass
    try:
        m13_m03.run = run
    except NameError:
        pass
    try:
        m13_m03.sensor_logger_task = sensor_logger_task
    except NameError:
        pass
    try:
        m13_m03.stop_logging = stop_logging
    except NameError:
        pass
    # ---- setup ----
    """
    【ロボット初期化ファイル】
    このファイルは、ロボットを使い始める前に必要な「準備作業」をまとめたものです。
    料理を始める前に、材料を並べたり、調理器具を準備するのと同じように、
    ロボットもプログラムを動かす前に、モーターやセンサーの設定が必要です。

    【このファイルでやること】
    1. ハブ（ロボットの脳みそ）の向きを設定
    2. モーター（タイヤやアームを動かす装置）の設定
    3. ロボットの速度やパワーの設定
    4. PID制御（ロボットをまっすぐ動かすための調整機能）の設定
    5. センサーの初期化

    【使い方】
    他のプログラムから「initialize_robot()」という関数を呼ぶだけで、
    すべての準備が自動的に完了します。
    """

    # ===== ライブラリのインポート =====
    # LEGOロボットを動かすために必要な道具を読み込みます
    from pybricks.hubs import PrimeHub  # ロボットの「脳みそ」（ハブ）を使うための道具
    from pybricks.parameters import Axis, Direction, Port  # ポート、軸、方向などの設定
    from pybricks.pupdevices import Motor  # モーターを使うための道具
    from pybricks.robotics import DriveBase  # ロボットの移動機能を使うための道具
    from pybricks.tools import StopWatch, wait

    # ===== デフォルトの速度・加速度設定 =====
    # 各runファイルから共通で使用できる設定値

    # 直進時の設定
    DEFAULT_STRAIGHT_SETTINGS = {"straight_speed": 400, "straight_acceleration": 500}

    # 回転時の設定
    DEFAULT_TURN_SETTINGS = {"turn_rate": 240, "turn_acceleration": 850}

    # カーブ時の設定
    DEFAULT_CURVE_SETTINGS = {"straight_speed": 240, "straight_acceleration": 800}


    async def run_with_timeout(start_fn, done_fn, stop_fn, timeout_ms, poll_ms=10):
        """
        非同期ループで完了を監視し、タイムアウトで停止する共通関数。
        """
        start_fn()
        timer = StopWatch()
        timer.reset()

        while timer.time() < timeout_ms:
            if done_fn():
                return True
            await wait(poll_ms)

        stop_fn()
        return False


    def apply_curve_settings(set_settings_fn, speed=None, acceleration=None):
        """
        カーブ用の速度・加速度設定を適用するユーティリティ。
        """
        params = {}
        if speed is not None:
            params["straight_speed"] = speed
        if acceleration is not None:
            params["straight_acceleration"] = acceleration
        if params:
            set_settings_fn(**params)


    # ===== ハブの設定をする関数 =====
    def setup_hub():
        """
        ハブ（ロボットの脳みそ）の向きを設定する関数

        【説明】
        ハブには「どちらが上か」「どちらが前か」を教える必要があります。
        これを正しく設定しないと、ロボットが正しく動きません。

        【設定内容】
        - top_side=Axis.Z : Z軸が上向き
        - front_side=Axis.X : X軸が前向き
        """
        return PrimeHub(top_side=Axis.Z, front_side=Axis.X)


    # ===== モーターの設定をする関数 =====
    def setup_motors():
        """
        4つのモーター（左右のタイヤ、左右のリフト）を設定する関数

        【説明】
        ロボットには4つのモーターがあります：
        1. 左のタイヤ用モーター
        2. 右のタイヤ用モーター
        3. 左のリフト（アーム）用モーター
        4. 右のリフト（アーム）用モーター

        それぞれのモーターがどのポート（差し込み口）に接続されているか、
        どちらの方向を「正」とするかを設定します。

        【ポートの接続】
        - Port.F : 左タイヤ（反時計回りが正の方向）
        - Port.B : 右タイヤ（時計回りが正の方向）
        - Port.E : 左リフト（時計回りが正の方向）
        - Port.A : 右リフト（時計回りが正の方向）
        """
        # 左タイヤのモーター（ポートFに接続、反時計回りが正）
        left_wheel = Motor(Port.F, positive_direction=Direction.COUNTERCLOCKWISE)
        # 右タイヤのモーター（ポートBに接続、時計回りが正）
        right_wheel = Motor(Port.B, positive_direction=Direction.CLOCKWISE)
        # 左リフトのモーター（ポートEに接続、時計回りが正）
        left_lift = Motor(Port.E, positive_direction=Direction.CLOCKWISE)
        # 右リフトのモーター（ポートAに接続、時計回りが正）
        right_lift = Motor(Port.A, positive_direction=Direction.CLOCKWISE)

        # 4つのモーターをまとめて返す
        return left_wheel, right_wheel, left_lift, right_lift


    # ===== Robotクラス（DriveBaseのラッパー） =====
    class Robot:
        """
        DriveBaseをラップした便利なロボットクラス

        【このクラスの特徴】
        straight(), turn(), curve() でスピードを直接指定できます。

        【使用例】
        await robot.straight(200, speed=220)       # 220mm/sで200mm前進
        await robot.turn(90, rate=300)              # 300deg/sで90度回転
        await robot.curve(200, 45, speed=150)       # 150mm/sでカーブ

        スピードを指定しない場合は、デフォルト設定が使われます。
        """

        def __init__(self, drivebase):
            """DriveBaseを受け取って初期化"""
            self._robot = drivebase

        async def straight(self, distance, speed=None, acceleration=None, timeout=None):
            """
            直進する（スピード・タイムアウト指定可能）

            【パラメータ】
            - distance: 移動距離（mm）。正の値で前進、負の値で後退
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if speed is not None or acceleration is not None:
                self._robot.settings(
                    straight_speed=(
                        speed if speed is not None else DEFAULT_STRAIGHT_SETTINGS["straight_speed"]
                    ),
                    straight_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_STRAIGHT_SETTINGS["straight_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.straight(distance, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await self._robot.straight(distance)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def turn(self, angle, rate=None, acceleration=None, timeout=None):
            """
            その場で回転する（スピード・タイムアウト指定可能）

            【パラメータ】
            - angle: 回転角度（度）。正の値で右回転、負の値で左回転
            - rate: 回転速度（deg/s）。省略時はデフォルト設定
            - acceleration: 回転加速度（deg/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定
            if rate is not None or acceleration is not None:
                self._robot.settings(
                    turn_rate=rate if rate is not None else DEFAULT_TURN_SETTINGS["turn_rate"],
                    turn_acceleration=(
                        acceleration
                        if acceleration is not None
                        else DEFAULT_TURN_SETTINGS["turn_acceleration"]
                    ),
                )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.turn(angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.turn(angle)

            # デフォルト設定に戻す
            if rate is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_TURN_SETTINGS)

        async def curve(self, radius, angle, speed=None, acceleration=None, timeout=None):
            """
            カーブする（スピード・タイムアウト指定可能）

            【パラメータ】
            - radius: カーブの半径（mm）
            - angle: 回転角度（度）
            - speed: 速度（mm/s）。省略時はデフォルト設定
            - acceleration: 加速度（mm/s²）。省略時はデフォルト設定
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし
            """
            # スピード設定（指定があれば上書き）
            apply_curve_settings(
                self._robot.settings,
                speed if speed is not None else None,
                acceleration if acceleration is not None else None,
            )

            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: self._robot.curve(radius, angle, wait=False),
                    done_fn=self._robot.done,
                    stop_fn=self._robot.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行
                await self._robot.curve(radius, angle)

            # デフォルト設定に戻す
            if speed is not None or acceleration is not None:
                self._robot.settings(**DEFAULT_STRAIGHT_SETTINGS)

        async def run_motor(self, motor, speed, angle, timeout=None):
            """
            個別のモーターを回転させる（タイムアウト指定可能）

            【パラメータ】
            - motor: 対象のモーター（left_wheel, right_wheel, left_lift, right_liftなど）
            - speed: 回転速度（deg/s）
            - angle: 回転角度（度）
            - timeout: タイムアウト時間（ミリ秒）。省略時はタイムアウトなし

            【使用例】
            await robot.run_motor(right_wheel, 200, 140, timeout=1500)
            await robot.run_motor(left_lift, 300, 180)
            """
            if timeout is not None:
                # タイムアウト付きで実行
                await run_with_timeout(
                    start_fn=lambda: motor.run_angle(speed, angle, wait=False),
                    done_fn=lambda: motor.control.done(),
                    stop_fn=motor.stop,
                    timeout_ms=timeout,
                )
            else:
                # 通常の実行（完了まで待つ）
                await motor.run_angle(speed, angle)

        # ----- 元のDriveBaseのメソッドをそのまま使えるようにする -----
        def stop(self):
            """ロボットを停止"""
            self._robot.stop()

        def reset(self):
            """走行距離などをリセット"""
            self._robot.reset()

        def distance(self):
            """走行距離を取得"""
            return self._robot.distance()

        def settings(self, **kwargs):
            """設定を変更（元のDriveBase.settingsと同じ）"""
            self._robot.settings(**kwargs)

        def done(self):
            """現在の移動が完了したかどうか"""
            return self._robot.done()

        def use_gyro(self, use):
            """ジャイロセンサーの使用設定"""
            self._robot.use_gyro(use)

        def distance_control(self):
            """距離制御（PID設定用）"""
            return self._robot.distance_control

        def heading_control(self):
            """方向制御（PID設定用）"""
            return self._robot.heading_control


    # ===== ロボットのパラメータ（動作の設定）をする関数 =====
    def setup_robot_parameters(left_wheel, right_wheel):
        """
        ロボットの動く速度を設定する関数

        【説明】
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで定義された
        デフォルト値が自動的に適用されます。

        【返り値】
        Robotクラスのインスタンス（DriveBaseをラップしたもの）
        """

        # ----- ロボットの物理的な大きさを設定 -----
        drivebase = DriveBase(
            left_wheel,  # 左タイヤのモーター
            right_wheel,  # 右タイヤのモーター
            wheel_diameter=62,  # タイヤの直径（mm）
            axle_track=115,  # 左右のタイヤの間隔（mm）
        )

        # ----- デフォルトの速度・加速度を自動適用 -----
        drivebase.settings(**DEFAULT_STRAIGHT_SETTINGS, **DEFAULT_TURN_SETTINGS)
        print(f"✓ デフォルト設定適用: 直進={DEFAULT_STRAIGHT_SETTINGS}, 回転={DEFAULT_TURN_SETTINGS}")

        # Robotクラスでラップして返す
        return Robot(drivebase)


    # ===== PID制御の設定をする関数 =====
    def setup_pid_control(robot):
        """
        PID制御を設定する関数

        【PID制御とは？】
        ロボットをまっすぐ正確に動かすための「自動調整機能」です。

        例えば、車を運転するときに、カーブでハンドルを少しずつ調整しますよね？
        PID制御は、ロボットが自動的にこの調整をしてくれる機能です。

        【PIDの意味】
        - P (Proportional: 比例) : 目標からどれくらいズレているかに応じて調整
        - I (Integral: 積分) : 過去のズレを積み重ねて調整
        - D (Derivative: 微分) : ズレの変化の速さに応じて調整

        【2種類のPID制御】
        1. 距離制御 (DISTANCE) : 「どれくらい進むか」を正確にコントロール
        2. 方向制御 (HEADING) : 「どの方向を向くか」を正確にコントロール

        【注意】
        下の数値（KP, KI, KD）は「ゲイン」と呼ばれ、調整の強さを決めます。
        この数値を変えると、ロボットの動きが変わります。
        うまく動かない場合は、これらの数値を調整する必要があります。
        """

        # ----- 距離制御用のPIDゲイン（「進む距離」をコントロール） -----
        DISTANCE_KP = 1000  # P（比例）ゲイン: 目標との距離差に対する反応の強さ
        DISTANCE_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        DISTANCE_KD = 10  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- 方向制御用のPIDゲイン（「向き」をコントロール） -----
        HEADING_KP = 2000  # P（比例）ゲイン: 目標との角度差に対する反応の強さ
        HEADING_KI = 50  # I（積分）ゲイン: 過去のズレを修正する強さ
        HEADING_KD = 100  # D（微分）ゲイン: 急な変化を抑える強さ

        # ----- ロボットにPIDゲインを設定 -----
        # 距離制御のPIDゲインを設定
        robot.distance_control().pid(kp=DISTANCE_KP, ki=DISTANCE_KI, kd=DISTANCE_KD)

        # 方向制御のPIDゲインを設定
        robot.heading_control().pid(kp=HEADING_KP, ki=HEADING_KI, kd=HEADING_KD)


    # ===== センサーを初期化する関数 =====
    def initialize_sensors(hub, robot):
        """
        センサーとジャイロ（方向センサー）を初期化する関数

        【説明】
        ロボットには「ジャイロセンサー」という、スマートフォンの画面回転機能と同じような
        センサーが付いています。これは「ロボットがどちらを向いているか」を測定します。

        【やること】
        1. ジャイロセンサーを使用する設定にする
        2. 方向を0度（まっすぐ）にリセット
        3. ロボットの走行距離などをリセット

        【なぜ必要？】
        プログラムを実行する前に、「今がスタート地点」だと教える必要があります。
        これをしないと、前のプログラムの影響が残ってしまいます。
        """
        robot.use_gyro(True)  # ジャイロセンサーを使う設定にする
        hub.imu.reset_heading(0)  # 方向を0度（正面）にリセット
        robot.reset()  # ロボットの走行距離や回転角度をリセット


    # ===== モーターの角度をリセットする関数 =====
    def reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift):
        """
        すべてのモーターの角度を0度にリセットする関数

        【説明】
        モーターは回転した角度を記録しています。
        例えば、タイヤが360度回転したら「1回転した」と記録されます。

        この関数は、すべてのモーターの角度を0度に戻します。
        時計の針を12時の位置に戻すようなイメージです。

        【対象モーター】
        - 左タイヤ
        - 右タイヤ
        - 左リフト（アーム）
        - 右リフト（アーム）

        【なぜ必要？】
        プログラムを実行する前に、モーターの角度をリセットしないと、
        「前回どこまで回転したか」の情報が残ってしまい、正確に動きません。
        """
        left_wheel.reset_angle(0)  # 左タイヤのモーターを0度にリセット
        right_wheel.reset_angle(0)  # 右タイヤのモーターを0度にリセット
        left_lift.reset_angle(0)  # 左リフトのモーターを0度にリセット
        right_lift.reset_angle(0)  # 右リフトのモーターを0度にリセット
        print("✓ モーター角度リセット完了: 全モーター=0°")


    # ===== ロボット全体を初期化する関数（メイン関数） =====
    def initialize_robot():
        """
        ロボットを使う準備を全部まとめて行う関数

        【説明】
        この関数は、上で定義した5つの関数をすべて実行して、
        ロボットを使えるようにします。
        速度・加速度はDEFAULT_STRAIGHT_SETTINGS、DEFAULT_TURN_SETTINGSで
        定義されたデフォルト値が自動的に適用されます。

        【実行する処理（順番通り）】
        1. ハブの設定
        2. モーターの設定
        3. ロボットパラメータの設定
        4. PID制御の設定
        5. センサーの初期化
        6. モーター角度のリセット

        【返り値（戻ってくる値）】
        この関数は、以下の6つの情報を返します：
        - hub : ハブ（ロボットの脳みそ）
        - robot : ロボット全体のオブジェクト
        - left_wheel : 左タイヤのモーター
        - right_wheel : 右タイヤのモーター
        - left_lift : 左リフトのモーター
        - right_lift : 右リフトのモーター

        【使い方の例】
        他のプログラムから以下のように使います：
        hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        """
        print("=== ロボット初期化開始 ===")

        # ----- ステップ1: ハブの設定 -----
        hub = setup_hub()
        print("✓ ハブ設定完了")

        # ----- ステップ2: モーターの設定 -----
        left_wheel, right_wheel, left_lift, right_lift = setup_motors()
        print("✓ モーター設定完了")

        # ----- ステップ3: ロボットパラメータの設定 -----
        robot = setup_robot_parameters(left_wheel, right_wheel)
        print("✓ ロボットパラメータ設定完了")

        # ----- ステップ4: PID制御の設定 -----
        setup_pid_control(robot)
        print("✓ PID制御設定完了")

        # ----- ステップ5: センサーの初期化 -----
        initialize_sensors(hub, robot)
        print("✓ センサー初期化完了")

        # ----- ステップ6: モーター角度のリセット -----
        reset_motor_angles(left_wheel, right_wheel, left_lift, right_lift)

        print("=== ロボット初期化完了 ===")

        # ----- すべての設定情報を返す -----
        return hub, robot, left_wheel, right_wheel, left_lift, right_lift
    # ---- main ----
    from pybricks.tools import StopWatch, multitask, run_task, wait
    _variant_M03_M04 = M03_M04
    _variant_M03_M04_ayumu_01_30 = M03_M04_ayumu_01_30
    _variant_m13_m03 = m13_m03

    CURRENT_MISSION = None
    ACTIVE_VARIANT = "M03_M04_ayumu_01_30"
    VARIANTS = {
        "M03_M04_ayumu_01_30": _variant_M03_M04_ayumu_01_30,
        "M03_M04": _variant_M03_M04,
        "m13_m03": _variant_m13_m03,
    }


    async def run_with_timing(label, coro_fn):
        timer = StopWatch()
        timer.reset()
        print(f"[RUN] {label} start")
        result = await coro_fn()
        elapsed_ms = timer.time()
        print(f"[RUN] {label} done ({elapsed_ms:.0f} ms)")
        return result


    def get_active_variant_name():
        if isinstance(CURRENT_MISSION, str) and CURRENT_MISSION in VARIANTS:
            return CURRENT_MISSION
        for name, variant in VARIANTS.items():
            if getattr(variant, "IS_CURRENT", False):
                return name
        return ACTIVE_VARIANT


    def load_variant():
        name = get_active_variant_name()
        return name, VARIANTS[name]


    async def run(hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        variant_name, variant = load_variant()
        label = f"run06:{variant_name}"
        return await run_with_timing(
            label,
            lambda: variant.run(
                hub,
                robot,
                left_wheel,
                right_wheel,
                left_lift,
                right_lift,
            ),
        )

    def main(hub=None, robot=None, left_wheel=None, right_wheel=None, left_lift=None, right_lift=None):
        if hub is None:
            hub, robot, left_wheel, right_wheel, left_lift, right_lift = initialize_robot()
        variant_name, variant = load_variant()
        label = f"run06:{variant_name}"

        async def timed_run():
            await run_with_timing(
                label,
                lambda: variant.run(
                    hub,
                    robot,
                    left_wheel,
                    right_wheel,
                    left_lift,
                    right_lift,
                ),
            )

        if hasattr(variant, "sensor_logger_task"):
            if "stop_logging" in globals():

                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)

                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        wrapped_run(),
                    )
                )
            else:
                run_task(
                    multitask(
                        variant.sensor_logger_task(hub, robot, left_wheel, right_wheel),
                        timed_run(),
                    )
                )
        else:
            run_task(timed_run())
    # ---- run entry ----
    async def _run_entry(ctx):
        variant = load_variant()
        has_stop_logging = "stop_logging" in globals()
        async def timed_run():
            await run(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel, ctx.left_lift, ctx.right_lift)
        if hasattr(variant, "sensor_logger_task"):
            if has_stop_logging:
                async def wrapped_run():
                    await timed_run()
                    globals()["stop_logging"] = True
                    await wait(500)
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), wrapped_run())
            else:
                await multitask(variant.sensor_logger_task(ctx.hub, ctx.robot, ctx.left_wheel, ctx.right_wheel), timed_run())
        else:
            await timed_run()
    return RunBundle(initialize_robot, _run_entry)

RUN_MAX = 6

RUNNERS = {
    "1": _make_run01,
    "2": _make_run02,
    "3": _make_run03,
    "4": _make_run04,
    "5": _make_run05,
    "6": _make_run06
}
class StopRequested(Exception):
    pass


class RunContext:
    def __init__(self, hub, robot, left_wheel, right_wheel, left_lift, right_lift):
        self.hub = hub
        self.robot = robot
        self.left_wheel = left_wheel
        self.right_wheel = right_wheel
        self.left_lift = left_lift
        self.right_lift = right_lift


class RunBundle:
    def __init__(self, setup_fn, run_fn):
        self.setup = setup_fn
        self.run = run_fn


def _get_hub():
    global _HUB
    if _HUB is None:
        _HUB = PrimeHub()
    return _HUB


def _get_touch():
    global _TOUCH
    if _TOUCH is None:
        _TOUCH = _detect_touch_sensor()
    return _TOUCH


def _set_stop_button(buttons):
    hub = _get_hub()
    try:
        hub.system.set_stop_button(buttons)
    except Exception:
        pass


def _detect_touch_sensor():
    for port in (Port.A, Port.B, Port.C, Port.D, Port.E, Port.F):
        try:
            return ForceSensor(port)
        except Exception:
            pass
    return None


def _touch_pressed():
    sensor = _get_touch()
    if sensor is None:
        return False
    try:
        return sensor.pressed()
    except Exception:
        try:
            return sensor.touched()
        except Exception:
            return False


def _wait_touch_release():
    sensor = _get_touch()
    if sensor is None:
        return
    while _touch_pressed():
        wait(20)


def _read_last_selection():
    hub = _get_hub()
    try:
        data = hub.system.storage(STORAGE_OFFSET, read=STORAGE_LEN)
    except Exception:
        return None
    if not data:
        return None
    value = data[0]
    if value == 0:
        return None
    if RUN_MIN <= value <= RUN_MAX:
        return value
    return None


def _write_last_selection(value):
    if not (RUN_MIN <= value <= RUN_MAX):
        return
    hub = _get_hub()
    try:
        hub.system.storage(STORAGE_OFFSET, write=bytes([int(value)]))
    except Exception:
        pass


def _wait_for_release(button):
    hub = _get_hub()
    while True:
        try:
            if button not in hub.buttons.pressed():
                return
        except Exception:
            pass
        wait(20)


def _stop_all_motors():
    ctx = _LAST_CONTEXT
    if not ctx:
        return
    try:
        ctx[1].stop()
    except Exception:
        pass
    for motor in ctx[2:]:
        try:
            motor.stop()
        except Exception:
            pass


async def _monitor_stop():
    hub = _get_hub()
    while True:
        try:
            pressed = hub.buttons.pressed()
        except Exception:
            pressed = []
        if Button.CENTER in pressed:
            _stop_all_motors()
            raise StopRequested("center stop")
        await wait(20)


def _run_selected(selected):
    factory = RUNNERS.get(str(selected))
    if factory is None:
        return
    try:
        bundle = factory()
        ctx = RunContext(*bundle.setup())
        global _LAST_CONTEXT
        _LAST_CONTEXT = ctx
        run_task(multitask(_monitor_stop(), bundle.run(ctx)))
    except StopRequested:
        return
    except BaseException as exc:
        print("Run failed:", exc)
        _stop_all_motors()


def select_loop():
    _set_stop_button((Button.CENTER, Button.BLUETOOTH))
    selected = _read_last_selection() or RUN_MIN
    while True:
        hub = _get_hub()
        try:
            hub.display.text(str(int(selected)))
        except Exception:
            try:
                hub.display.number(int(selected))
            except Exception:
                pass
        if _touch_pressed():
            _wait_touch_release()
            _write_last_selection(selected)
            _run_selected(selected)
            _wait_touch_release()
        try:
            pressed = hub.buttons.pressed()
        except Exception:
            pressed = []
        if Button.LEFT in pressed:
            _wait_for_release(Button.LEFT)
            selected -= 1
            if selected < RUN_MIN:
                selected = RUN_MAX
            _write_last_selection(selected)
        elif Button.RIGHT in pressed:
            _wait_for_release(Button.RIGHT)
            selected += 1
            if selected > RUN_MAX:
                selected = RUN_MIN
            _write_last_selection(selected)
        wait(20)


def main():
    return select_loop()


if __name__ == "__main__":
    main()
